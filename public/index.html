<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="CR Golf">
    <meta name="application-name" content="CR Golf">
    <meta name="theme-color" content="#dc2626">
    <meta name="description" content="Company Retreat Golf Tournament - 8 Years of Ryder Cup Excellence">
    
    <!-- iOS Splash Screens -->
    <link rel="apple-touch-icon" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-180x180.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/icons/icon-167x167.png">
    
    <!-- Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/icons/icon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/icons/icon-16x16.png" sizes="16x16">
    
    <title>Company Retreat Golf Tournament</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #dc2626; /* Red as primary */
            --secondary: #1e3a8a; /* Navy blue as secondary */
            --accent: #ef4444; /* Lighter red */
            --gold: #fbbf24;
            --silver: #e5e7eb;
            --bronze: #f97316;
            --bg-dark: #ffffff; /* White background */
            --bg-light: #f9fafb; /* Light gray */
            --text-light: #111827; /* Dark text for white background */
            --text-muted: #6b7280;
            --success: #10b981;
            --danger: #dc2626;
            --card-bg: rgba(255, 255, 255, 0.9);
            --border: rgba(229, 231, 235, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #ffffff;
            color: var(--text-light);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(220, 38, 38, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(30, 58, 138, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 2rem 80px 2rem; /* Add bottom padding for fixed nav */
            position: relative;
            z-index: 2;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.8s ease-out;
            position: relative;
        }

        .logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo svg {
            width: 100%;
            height: 100%;
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-muted);
            font-weight: 400;
        }

        .tabs {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            gap: 0;
            background: var(--bg-dark);
            padding: 0;
            border-top: 1px solid var(--border);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
            height: 60px;
        }

        .tab {
            flex: 1;
            padding: 0.5rem;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            border-radius: 0;
            position: relative;
        }

        .tab:hover {
            background: rgba(220, 38, 38, 0.1);
            color: var(--primary);
        }

        .tab.active {
            background: transparent;
            color: var(--primary);
            box-shadow: none;
        }

        .tab.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary);
        }

        .content {
            background: var(--card-bg);
            border-radius: 1.5rem;
            padding: 2rem;
            border: 1px solid var(--border);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            animation: fadeInUp 0.8s ease-out 0.5s both;
            min-height: 600px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 2px solid var(--primary);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(220, 38, 38, 0.1) 0%, transparent 70%);
            transform: rotate(45deg);
            transition: opacity 0.3s ease;
            opacity: 0;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(220, 38, 38, 0.2);
            border-color: var(--accent);
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        th {
            background: rgba(220, 38, 38, 0.1);
            font-weight: 600;
            color: var(--primary);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tr:hover {
            background: rgba(220, 38, 38, 0.05);
        }

        .champion-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: linear-gradient(135deg, var(--gold) 0%, #f59e0b 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 2rem;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .winner {
            color: var(--primary);
            font-weight: 600;
        }

        .loser {
            color: var(--text-muted);
        }

        .player-card {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 2px solid var(--border);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .player-card:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(220, 38, 38, 0.2);
            border-color: var(--primary);
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--secondary);
        }

        .record {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
        }

        .wins { color: var(--success); }
        .losses { color: var(--danger); }
        .ties { color: var(--text-muted); }

        .rank-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 1.1rem;
        }

        .rank-1 { background: var(--gold); color: var(--text-light); }
        .rank-2 { background: var(--silver); color: var(--text-light); }
        .rank-3 { background: var(--bronze); color: white; }

        .year-card {
            background: white;
            border: 2px solid var(--primary);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
        }

        .year-card:hover {
            box-shadow: 0 5px 20px rgba(220, 38, 38, 0.1);
            border-color: var(--accent);
        }

        .year-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .year-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .score {
            font-size: 1.8rem;
            font-weight: 800;
        }

        .captain-info {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .perfect-attendance {
            background: var(--secondary);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 0.3rem;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .scrollable {
            max-height: 600px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .scrollable::-webkit-scrollbar {
            width: 8px;
        }

        .scrollable::-webkit-scrollbar-track {
            background: var(--bg-light);
            border-radius: 4px;
        }

        .scrollable::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        .scrollable::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .filter-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.5rem 1rem;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 0.5rem;
            color: var(--primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .filter-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        .filter-btn.active {
            background: var(--primary);
            color: white;
        }

        .stat-of-day {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.1) 0%, rgba(30, 58, 138, 0.1) 100%);
            border: 2px solid var(--primary);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 2rem;
            text-align: center;
            animation: fadeIn 1s ease-out 0.5s both;
        }

        .stat-of-day .stat-label {
            color: var(--primary);
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .stat-of-day .stat-content {
            color: var(--text-light);
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .stat-highlight {
            color: var(--primary);
            font-weight: 600;
        }

        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 2px solid var(--primary);
            margin-bottom: 1.5rem;
        }

        .metric-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 1rem;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .metric-item:last-child {
            border-bottom: none;
        }

        .handicap-trend {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            font-size: 0.9rem;
        }

        .trend-up {
            color: var(--success);
        }

        .trend-down {
            color: var(--danger);
        }

        .upset-marker {
            background: var(--accent);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 0.3rem;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }
    </style>
    
    <!-- Add XLSX library for reading Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <img src="/images/company retreat logo simple_color.png" alt="Company Retreat Golf Logo" style="width: 100%; height: 100%; object-fit: contain;">
            </div>
            <h1>Company Retreat</h1>
            <p class="subtitle">8 Years of Ryder Cup Golf Excellence</p>
            <div id="stat-of-day" class="stat-of-day">
                <div class="stat-label">Stat of the Day</div>
                <div class="stat-content"></div>
            </div>
        </header>

        <div class="tabs">
            <button class="tab active" onclick="showTab('home', event)">
                <span style="font-size: 1.2rem;">🏠</span>
                <span>2025</span>
            </button>
            <button class="tab" onclick="showTab('history', event)">
                <span style="font-size: 1.2rem;">📜</span>
                <span>History</span>
            </button>
            <button class="tab" onclick="showTab('players', event)">
                <span style="font-size: 1.2rem;">👥</span>
                <span>Players</span>
            </button>
            <button class="tab" onclick="showTab('analytics', event)">
                <span style="font-size: 1.2rem;">📊</span>
                <span>Analytics</span>
            </button>
            <button class="tab" onclick="showTab('trends', event)">
                <span style="font-size: 1.2rem;">📈</span>
                <span>Trends</span>
            </button>
        </div>

        <div class="content" id="content">
            <div class="loading">Loading tournament data...</div>
        </div>
    </div>

    <script>
        console.log('Script starting execution...');
        
        // Tournament Data (will be loaded from Excel)
        /* const tournamentData = {
            years: {
                2018: { winner: "Portal", loser: "Pete", score: "9-7", captains: { Portal: "Javi Portal", Pete: "Pete Cabrera" } },
                2019: { winner: "Al", loser: "Skip", score: "9-7", captains: { Al: "Alex Lastra", Skip: "Skippy Ramirez" } },
                2020: { winner: "Vic", loser: "Javi", score: "15-9", captains: { Vic: "Victor Riobueno", Javi: "Javi Vargas" } },
                2021: { winner: "Danny", loser: "Mario", score: "15.5-8.5", captains: { Danny: "Danny Yanez", Mario: "Mario Martinez" } },
                2022: { winner: "Jo", loser: "Shawn", score: "12.5-11.5", captains: { Jo: "Jo Noy", Shawn: "Shawn Noy" } },
                2023: { winner: "Stu", loser: "Wes", score: "13-11", captains: { Stu: "Stuart Briggle", Wes: "Wes Briggle" } },
                2024: { winner: "Victor", loser: "Carlos", score: "15-13", captains: { Victor: "Victor Garcia", Carlos: "Carlos Enjamio" } },
                2025: { winner: "Pardo", loser: "Salas", score: "15.5-8.5", captains: { Pardo: "Lawrence Pardo", Salas: "Javi Salas" } }
            },
            players: [
                { rank: 1, name: "Danny Yanez", crs: 8, wins: 19, losses: 5, ties: 0, rating: 652, perfectAttendance: true },
                { rank: 2, name: "Javi Portal", crs: 8, wins: 14, losses: 9, ties: 1, rating: 582, perfectAttendance: true },
                { rank: 3, name: "Alex Lastra", crs: 7, wins: 15, losses: 5, ties: 1, rating: 504 },
                { rank: 4, name: "Jordan Portal", crs: 7, wins: 13, losses: 8, ties: 0, rating: 473 },
                { rank: 5, name: "Pete Cabrera", crs: 8, wins: 12, losses: 12, ties: 0, rating: 451, perfectAttendance: true },
                { rank: 6, name: "Victor Riobueno", crs: 8, wins: 12, losses: 11, ties: 1, rating: 451, perfectAttendance: true },
                { rank: 7, name: "Javi Vargas", crs: 7, wins: 9, losses: 10, ties: 2, rating: 425 },
                { rank: 8, name: "Carlos Enjamio", crs: 6, wins: 8, losses: 7, ties: 3, rating: 416 },
                { rank: 9, name: "Lawrence Pardo", crs: 7, wins: 9, losses: 9, ties: 3, rating: 416 },
                { rank: 10, name: "Michael Quintana", crs: 6, wins: 9, losses: 7, ties: 2, rating: 398 },
                { rank: 11, name: "Boogie Lastra", crs: 5, wins: 8, losses: 7, ties: 0, rating: 383, neverWon: true },
                { rank: 12, name: "Carlos Alfonso", crs: 5, wins: 8, losses: 7, ties: 0, rating: 383 },
                { rank: 13, name: "Jo Noy", crs: 6, wins: 9, losses: 9, ties: 0, rating: 378 },
                { rank: 14, name: "Shawn Noy", crs: 5, wins: 5, losses: 9, ties: 1, rating: 320, neverWon: true },
                { rank: 15, name: "Mario Martinez", crs: 4, wins: 5, losses: 7, ties: 0, rating: 300, neverWon: true },
                { rank: 16, name: "David Del Cristo", crs: 4, wins: 5, losses: 6, ties: 1, rating: 295, neverWon: true }
            ]
        }; */

        // Complete course data for all years
        const courseData = {
            2018: {
                scramble: { course: "Unknown", rating: 0, slope: 0 },
                bestBall: { course: "Unknown", rating: 0, slope: 0 },
                singles: { course: "Unknown", rating: 0, slope: 0 }
            },
            2019: {
                scramble: { course: "Unknown", rating: 0, slope: 0 },
                bestBall: { course: "Unknown", rating: 0, slope: 0 },
                singles: { course: "Unknown", rating: 0, slope: 0 }
            },
            2020: {
                scramble: { course: "West Palm Beach Par 3", rating: 52.9, slope: 113 },
                bestBall: { course: "Abacoa Golf Club (White)", rating: 70.2, slope: 132 },
                singles: { course: "Trump Doral Red Tiger (Gold)", rating: 69.6, slope: 132 }
            },
            2021: {
                scramble: { course: "Disney's Magnolia", rating: 69.6, slope: 126 },
                bestBall: { course: "Disney's Palm (Gold)", rating: 68.7, slope: 124 },
                singles: { course: "Southern Dunes (White)", rating: 70.4, slope: 133 }
            },
            2022: {
                scramble: { course: "Royal St. Cloud", rating: 70.9, slope: 126 },
                bestBall: { course: "Reunion Watson (Blue)", rating: 70.8, slope: 126 },
                singles: { course: "Reunion Nicklaus (Blue)", rating: 71.4, slope: 133 }
            },
            2023: {
                scramble: { course: "Reunion Nicklaus (Blue)", rating: 71.4, slope: 133 },
                bestBall: { course: "Grand Cypress Links (Blue)", rating: 70.4, slope: 117 },
                singles: { course: "Celebration (Gold)", rating: 72.1, slope: 135 }
            },
            2024: {
                scramble: { course: "Reunion Palmer (Gold)", rating: 70.9, slope: 133 },
                bestBall: { course: "OC National Panther Lake", rating: 71.2, slope: 132 },
                singles: { course: "Champions Gate Int'l (Blue)", rating: 73.0, slope: 132 }
            },
            2025: {
                scramble: { course: "Reunion Palmer (Gold)", rating: 70.9, slope: 133 },
                bestBall: { course: "Disney's Magnolia (White)", rating: 71.6, slope: 130 },
                singles: { course: "Waldorf Astoria (Blue/White)", rating: 71.7, slope: 137 }
            }
        };

        // Initialize empty data structures
        let matchData = {};
        let handicapData = {};
        
        // Initialize handicapData with fallback values ONLY if no data loaded from Excel
        function initializeHandicapData() {
            if (Object.keys(handicapData).length === 0) {
                console.log('No handicap data loaded from Excel, using fallback data');
                handicapData = { ...handicapDataFallback };
            } else {
                console.log('Handicap data loaded from Excel:', Object.keys(handicapData).length, 'players');
            }
        }
        
        // Validate and fix handicap data - use fallback for unrealistic values
        function validateAndFixHandicapData() {
            console.log('Validating handicap data...');
            
            Object.entries(handicapData).forEach(([playerName, yearData]) => {
                Object.entries(yearData).forEach(([year, hcp]) => {
                    // Check for unrealistic handicap values
                    if (hcp > 50 || hcp < -5) {
                        console.log(`Invalid handicap for ${playerName} in ${year}: ${hcp}`);
                        
                        // Use fallback data if available
                        if (handicapDataFallback[playerName] && handicapDataFallback[playerName][year] !== undefined) {
                            const fallbackHcp = handicapDataFallback[playerName][year];
                            console.log(`  Using fallback value: ${fallbackHcp}`);
                            handicapData[playerName][year] = fallbackHcp;
                        } else {
                            // Remove invalid value
                            delete handicapData[playerName][year];
                        }
                    }
                });
            });
            
            // Also ensure key players have data from fallback if missing
            const keyPlayers = ['Pete Cabrera', 'Jordan Portal', 'Danny Yanez', 'Javi Portal'];
            keyPlayers.forEach(playerName => {
                if (handicapDataFallback[playerName]) {
                    if (!handicapData[playerName]) {
                        handicapData[playerName] = {};
                    }
                    Object.entries(handicapDataFallback[playerName]).forEach(([year, hcp]) => {
                        if (handicapData[playerName][year] === undefined || 
                            handicapData[playerName][year] > 50 || 
                            handicapData[playerName][year] < -5) {
                            console.log(`Setting ${playerName} ${year} handicap to fallback value: ${hcp}`);
                            handicapData[playerName][year] = hcp;
                        }
                    });
                }
            });
            
            console.log('Handicap data validation complete');
        }
        
        // Get player's handicap for a specific year
        function getPlayerHandicap(playerName, year) {
            if (handicapData[playerName] && handicapData[playerName][year] !== undefined) {
                return handicapData[playerName][year];
            }
            return null;
        }
        
        // Format handicap for display
        function formatHandicap(hcp, playerName) {
            if (hcp === null || hcp === undefined) return 'N/A';
            
            // Only Jordan Portal gets plus handicaps displayed with +
            if (playerName === 'Jordan Portal' && hcp <= 3.5) {
                return '+' + Math.abs(hcp);
            }
            
            return hcp.toString();
        }
        
        let tournamentData = {
            players: [],
            captainHistory: []
        };

        let currentTab = 'overview';

        // Define showTab early so it's available for onclick handlers
        function showTab(tab, event) {
            currentTab = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            
            // If called from a click event, update the active tab
            if (event && event.target) {
                event.target.closest('.tab').classList.add('active');
            } else {
                // If called programmatically, find the tab by data attribute or default to first
                const tabButton = document.querySelector(`[onclick*="'${tab}'"]`) || document.querySelector('.tab');
                if (tabButton) {
                    tabButton.classList.add('active');
                }
            }
            
            const content = document.getElementById('content');
            
            switch(tab) {
                case 'home':
                case '2025':
                    show2025Dashboard(content);
                    break;
                case 'history':
                    showHistory(content);
                    break;
                case 'players':
                    showPlayerAnalytics(content);
                    break;
                case 'analytics':
                    showAdvancedAnalytics(content);
                    break;
                case 'trends':
                    showTrends(content);
                    break;
            }
        }

        // Function to load and parse Excel data
        async function loadExcelData() {
            try {
                console.log('Starting Excel data load...');
                const response = await fetch('/CR History.xlsx');
                if (!response.ok) {
                    throw new Error(`Failed to fetch Excel file: ${response.status}`);
                }
                console.log('Excel file fetched successfully');
                const arrayBuffer = await response.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });
                console.log('Excel file parsed, sheets:', Object.keys(workbook.Sheets));
                
                // Debug: Check raw sheet structure for a year
                const debugYear = '2025';
                if (workbook.Sheets[debugYear]) {
                    console.log(`\nDEBUG: Raw sheet structure for ${debugYear}:`);
                    const sheet = workbook.Sheets[debugYear];
                    console.log('Sheet keys:', Object.keys(sheet).slice(0, 20)); // Show first 20 cell references
                    console.log('Cell A1:', sheet['A1']);
                    console.log('Cell B1:', sheet['B1']);
                    console.log('Cell C1:', sheet['C1']);
                    console.log('Cell D1:', sheet['D1']);
                    console.log('Cell E1:', sheet['E1']);
                    console.log('Cell F1:', sheet['F1']);
                    console.log('Cell G1:', sheet['G1']);
                    console.log('Cell H1:', sheet['H1']);
                }
                
                // Process Players sheet for overall stats
                const playersSheet = workbook.Sheets['Players'];
                if (playersSheet) {
                    const playersData = XLSX.utils.sheet_to_json(playersSheet);
                    
                    tournamentData.players = playersData.map((player, idx) => {
                        // Calculate total W-L-T from format-specific records
                        const scrambleW = player['Scramble W'] || 0;
                        const scrambleL = player['Scramble L'] || 0;
                        const scrambleT = player['Scramble T'] || 0;
                        const bestBallW = player['Best Ball W'] || 0;
                        const bestBallL = player['Best Ball L'] || 0;
                        const bestBallT = player['Best Ball T'] || 0;
                        const singlesW = player['Singles W'] || 0;
                        const singlesL = player['Singles L'] || 0;
                        const singlesT = player['Singles T'] || 0;
                        
                        return {
                            rank: idx + 1,
                            name: player.Player,
                            crs: player.CRs || 0,
                            wins: player.W || (scrambleW + bestBallW + singlesW),
                            losses: player.L || (scrambleL + bestBallL + singlesL),
                            ties: player.T || (scrambleT + bestBallT + singlesT),
                            avgScore: player['Avg Score'] || 0,
                            avgNetScore: player['Avg Net Score'] || 0,
                            netHolesWon: player['Net Holes Won'] || 0,
                            rating: player.Rating || 0,
                            perfectAttendance: player.CRs === 8,
                            scrambleRecord: { W: scrambleW, L: scrambleL, T: scrambleT },
                            bestBallRecord: { W: bestBallW, L: bestBallL, T: bestBallT },
                            singlesRecord: { W: singlesW, L: singlesL, T: singlesT }
                        };
                    }).filter(p => p.name); // Filter out empty rows
                }
                
                // Process each year's data
                const years = ['2018', '2019', '2020', '2021', '2022', '2023', '2024', '2025'];
                
                for (const year of years) {
                    const sheet = workbook.Sheets[year];
                    if (!sheet) continue;
                    
                    // Use header:1 to get raw array data with ALL columns
                    const rawData = XLSX.utils.sheet_to_json(sheet, {
                        header: 1,  // This returns an array of arrays
                        defval: '', // Default value for empty cells
                        blankrows: true // Include blank rows
                    });
                    
                    console.log(`\n=== LOADING YEAR ${year} ===`);
                    console.log(`Total rows in ${year}:`, rawData.length);
                    console.log(`Total columns:`, rawData[0]?.length || 0);
                    
                    // Log headers to see column positions
                    if (rawData.length > 0) {
                        console.log('Headers row:', rawData[0]);
                        // Log column P (index 15) to column AU (index 46)
                        console.log('Scramble columns (P-Y):', rawData[0].slice(15, 25));
                        console.log('Best Ball columns (AA-AJ):', rawData[0].slice(26, 36));
                        console.log('Singles columns (AL-AU):', rawData[0].slice(37, 47));
                    }
                    
                    // Pass raw data to processYearData
                    matchData[year] = processYearData(year, rawData);
                    
                    // Extract handicap data - need to find the correct column
                    console.log(`\nExtracting handicaps for ${year}...`);
                    
                    // Debug: Let's check what's in the first few rows to find the HCP column
                    if (rawData.length > 0) {
                        console.log('All headers:', rawData[0]);
                        if (rawData.length > 1) {
                            console.log('First player row:', rawData[1]);
                        }
                    }
                    
                    // Look for HCP column in headers - check columns in likely locations
                    // Based on the data structure: columns A-O are player data, P-Y scrambles, etc.
                    // HCP is likely in columns L, M, or N (indices 11, 12, 13)
                    let hcpColumnIndex = -1;
                    const likelyColumns = [11, 12, 13, 14]; // L, M, N, O
                    
                    for (let i of likelyColumns) {
                        if (rawData[0] && rawData[0][i]) {
                            const header = rawData[0][i];
                            console.log(`Checking column ${i} (${String.fromCharCode(65 + i)}): "${header}"`);
                            if (header && (header.toString().toUpperCase().includes('HCP') || 
                                         header.toString().toUpperCase().includes('HANDICAP') ||
                                         header.toString().toUpperCase() === 'HC' ||
                                         header.toString().toUpperCase() === 'HCP' ||
                                         header.toString().toUpperCase() === 'HDCP')) {
                                hcpColumnIndex = i;
                                console.log(`Found HCP column at index ${i} (column ${String.fromCharCode(65 + i)}): "${header}"`);
                                break;
                            }
                        }
                    }
                    
                    // If still not found, check ALL columns
                    if (hcpColumnIndex === -1 && rawData[0]) {
                        for (let i = 0; i < rawData[0].length && i < 15; i++) {
                            const header = rawData[0][i];
                            if (header && (header.toString().toUpperCase().includes('HCP') || 
                                         header.toString().toUpperCase().includes('HANDICAP') ||
                                         header.toString().toUpperCase() === 'HC' ||
                                         header.toString().toUpperCase() === 'HCP' ||
                                         header.toString().toUpperCase() === 'HDCP')) {
                                hcpColumnIndex = i;
                                console.log(`Found HCP column at index ${i}: "${header}"`);
                                break;
                            }
                        }
                    }
                    
                    // If we didn't find HCP column, default to column M (index 12)
                    if (hcpColumnIndex === -1) {
                        hcpColumnIndex = 12; // Column M
                        console.log(`HCP column not found. Defaulting to column M (index ${hcpColumnIndex})`);
                    }
                    
                    // Debug: Log the column we're using and sample values
                    if (rawData.length > 5) {
                        console.log(`Using column ${hcpColumnIndex} (${String.fromCharCode(65 + hcpColumnIndex)}) for handicaps`);
                        console.log('Sample values from this column:');
                        for (let i = 1; i <= 5 && i < rawData.length; i++) {
                            console.log(`  Row ${i+1}: "${rawData[i][hcpColumnIndex]}"`);
                        }
                        
                        // Also log Pete Cabrera's row specifically
                        for (let i = 1; i < rawData.length && i < 26; i++) {
                            if (rawData[i][0] === 'Pete Cabrera') {
                                console.log(`Pete Cabrera's full row (first 15 columns):`, rawData[i].slice(0, 15));
                                break;
                            }
                        }
                    }
                    
                    for (let i = 1; i < rawData.length && i < 26; i++) { // Players are in rows 2-25
                        const row = rawData[i];
                        const playerName = row[0]; // Column A
                        const hcp = row[hcpColumnIndex]; // HCP column
                        
                        if (playerName && hcp !== undefined && hcp !== '' && hcp !== null) {
                            if (!handicapData[playerName]) {
                                handicapData[playerName] = {};
                            }
                            
                            // Handle various handicap formats
                            let hcpValue = 0;
                            const hcpStr = hcp.toString().trim();
                            
                            // Remove any + sign (we'll add it back for display if needed)
                            const cleanHcp = hcpStr.replace('+', '');
                            hcpValue = parseFloat(cleanHcp) || 0;
                            
                            handicapData[playerName][year] = hcpValue;
                            
                            // Debug: Log specific players' data
                            if (playerName === 'Pete Cabrera' || playerName === 'Jordan Portal') {
                                console.log(`${playerName} ${year}: Column ${hcpColumnIndex} value="${hcp}" parsed=${hcpValue}`);
                            }
                        }
                    }
                    console.log(`Loaded ${Object.keys(handicapData).length} players' handicaps for ${year}`);
                }
                
                // Update tournament years data
                tournamentData.years = {
                    2025: { winner: "Pardo", loser: "Salas", score: "15.5-8.5", captains: { Pardo: "Lawrence Pardo", Salas: "Javi Salas" } },
                    2024: { winner: "Victor", loser: "Carlos", score: "15-13", captains: { Victor: "Victor Garcia", Carlos: "Carlos Enjamio" } },
                    2023: { winner: "Stu", loser: "Wes", score: "13-11", captains: { Stu: "Stuart Briggle", Wes: "Wes Briggle" } },
                    2022: { winner: "Jo", loser: "Shawn", score: "12.5-11.5", captains: { Jo: "Jo Noy", Shawn: "Shawn Noy" } },
                    2021: { winner: "Danny", loser: "Mario", score: "15.5-8.5", captains: { Danny: "Danny Yanez", Mario: "Mario Martinez" } },
                    2020: { winner: "Vic", loser: "Javi", score: "15-9", captains: { Vic: "Victor Riobueno", Javi: "Javi Vargas" } },
                    2019: { winner: "Al", loser: "Skip", score: "9-7", captains: { Al: "Alex Lastra", Skip: "Skippy Ramirez" } },
                    2018: { winner: "Portal", loser: "Pete", score: "9-7", captains: { Portal: "Javi Portal", Pete: "Pete Cabrera" } }
                };
                
                // Create playerList from loaded data
                const playerList = Array.from(new Set(
                    Object.values(matchData).flatMap(yearData => 
                        [...Object.values(yearData.teamData || {}).flat()]
                    )
                )).filter(Boolean).sort();
                
                // Make playerList global
                window.playerList = playerList;
                
                console.log('Excel data loaded successfully');
                console.log('Total players found:', playerList.length);
                console.log('Player list:', playerList);
                console.log('Match data keys:', Object.keys(matchData));
                
                // Initialize handicap data with fallback if needed
                initializeHandicapData();
                
                // Validate and fix handicap data
                validateAndFixHandicapData();
                
                // Initialize the app with the loaded data
                showTab('2025');
                displayRandomStat();
                
            } catch (error) {
                console.error('Error loading Excel file:', error);
                // Fall back to hardcoded data if Excel fails
                loadFallbackData();
            }
        }

        function processYearData(year, rawData) {
            console.log(`\n=== PROCESSING YEAR ${year} ===`);
            console.log(`Number of data rows: ${rawData.length}`);
            const result = {
                date: getYearDate(year),
                courses: getYearCourses(year),
                captains: {},
                finalScore: '',
                scrambleResults: [],
                bestBallResults: [],
                singlesResults: [],
                teamData: {},
                dailyScores: { friday: {}, saturday: {}, sunday: {} }
            };
            
            // Extract captain info - Row 28 for most years, Row 31 for 2024
            const captainRow = year === '2024' ? 30 : 27; // 0-indexed
            if (rawData[captainRow] && rawData[captainRow + 1]) {
                const captain1Name = rawData[captainRow][0]; // Column A
                const captain1Score = rawData[captainRow][1]; // Column B
                const captain2Name = rawData[captainRow + 1][0]; // Column A
                const captain2Score = rawData[captainRow + 1][1]; // Column B
                
                if (captain1Name && captain2Name) {
                    result.captains = { 
                        [captain1Name.toLowerCase().split(' ')[0]]: captain1Name,
                        [captain2Name.toLowerCase().split(' ')[0]]: captain2Name
                    };
                    result.finalScore = `${captain1Score}-${captain2Score}`;
                }
            }
            
            // If captains not found from data, use hardcoded values
            if (Object.keys(result.captains).length === 0) {
                result.captains = getYearCaptains(year);
                result.finalScore = getYearScore(year);
            }
            
            // Group players by team using column B (Team) - only include rows before captain row
            const teams = {};
            const seenPlayers = new Set();
            const teamKeys = Object.keys(result.captains);
            if (teamKeys.length === 2) {
                teams[teamKeys[0]] = [];
                teams[teamKeys[1]] = [];
            }
            
            for (let i = 1; i < captainRow && i < rawData.length; i++) {
                const playerName = rawData[i][0]; // Column A - Player
                const teamName = rawData[i][1]; // Column B - Team
                
                if (playerName && teamName && !seenPlayers.has(playerName)) {
                    seenPlayers.add(playerName);
                    // Find which team key matches this team name
                    const teamKey = teamKeys.find(key => 
                        teamName.toLowerCase().includes(key) || 
                        result.captains[key].toLowerCase().includes(teamName.toLowerCase())
                    );
                    if (teamKey && teams[teamKey]) {
                        teams[teamKey].push(playerName);
                    }
                }
            }
            result.teamData = teams;
            console.log(`Year ${year} teams:`, teams);
            console.log(`Year ${year} player count:`, seenPlayers.size);
            
            // Parse Scramble matches from columns P-Y (indices 15-24)
            // Pattern: Rows 2&3 vs 4&5, skip 6, then 7&8 vs 9&10, etc.
            const scrambleMatches = [];
            
            console.log(`\nParsing scramble matches for ${year}...`);
            
            // Process matches in groups of 4 rows with 1 row gap
            let rowIndex = 1; // Start at row 2 (index 1)
            while (rowIndex + 3 < rawData.length && rowIndex < captainRow) {
                const row1 = rawData[rowIndex];
                const row2 = rawData[rowIndex + 1];
                const row3 = rawData[rowIndex + 2];
                const row4 = rawData[rowIndex + 3];
                
                // Column indices for Scramble data (P-Y = indices 15-24)
                // P=15: Player, Q=16: Team, R=17: Gross, S=18: Net, T=19: Holes,
                // U=20: Net Holes Won/Lost, V=21: Holes Left, W=22: Adj Score,
                // X=23: Adj Net, Y=24: Result
                const P = 15;  // Player
                const Q = 16;  // Team
                const U = 20;  // Net Holes Won/Lost (Up/Dn)
                const V = 21;  // Holes Left
                const Y = 24;  // Result
                
                // Check if we have valid scramble data in these rows
                if (row1 && row1[P] && row1[Q] && row1[Y] &&
                    row2 && row2[P] && row2[Q] && row2[Y] &&
                    row3 && row3[P] && row3[Q] && row3[Y] &&
                    row4 && row4[P] && row4[Q] && row4[Y]) {
                    
                    // Verify rows 1&2 are same team and rows 3&4 are same team
                    if (row1[Q] === row2[Q] && row3[Q] === row4[Q] && row1[Q] !== row3[Q]) {
                        const teamNames = Object.keys(result.captains);
                        const team1 = teamNames[0];
                        const team2 = teamNames[1];
                        
                        // Determine which rows belong to which team
                        const team1Rows = row1[Q].toLowerCase().includes(team1) ? [row1, row2] : [row3, row4];
                        const team2Rows = row1[Q].toLowerCase().includes(team1) ? [row3, row4] : [row1, row2];
                        
                        // Get result from first player of team1
                        const team1Result = team1Rows[0][Y];
                        const winner = team1Result === 'W' ? team1 : team1Result === 'L' ? team2 : '';
                        
                        scrambleMatches.push({
                            match: scrambleMatches.length + 1,
                            [team1]: [team1Rows[0][P], team1Rows[1][P]],
                            [team2]: [team2Rows[0][P], team2Rows[1][P]],
                            result: team1Result,
                            score: formatMatchScore(team1Rows[0][U], team1Rows[0][V]),
                            winner: winner
                        });
                    }
                }
                
                // Skip 5 rows (4 player rows + 1 gap row)
                rowIndex += 5;
            }
            
            result.scrambleResults = scrambleMatches;
            console.log(`Found ${scrambleMatches.length} scramble matches for ${year}`);
            if (scrambleMatches.length > 0) {
                console.log('First scramble match:', scrambleMatches[0]);
            }
            
            // Parse Best Ball matches from columns AA-AJ (indices 26-35)
            // Same pattern as Scrambles: Rows 2&3 vs 4&5, skip 6, then 7&8 vs 9&10, etc.
            const bestBallMatches = [];
            
            // Column indices for Best Ball data (AA-AJ = indices 26-35)
            const AA = 26; // Player
            const AB = 27; // Team
            const AE = 30; // Net Holes Won/Lost
            const AF = 31; // Holes Left
            const AJ = 35; // Result
            
            // Process matches in groups of 4 rows with 1 row gap
            rowIndex = 1; // Reset for Best Ball
            while (rowIndex + 3 < rawData.length && rowIndex < captainRow) {
                const row1 = rawData[rowIndex];
                const row2 = rawData[rowIndex + 1];
                const row3 = rawData[rowIndex + 2];
                const row4 = rawData[rowIndex + 3];
                
                // Check if we have valid best ball data in these rows
                if (row1 && row1[AA] && row1[AB] && row1[AJ] &&
                    row2 && row2[AA] && row2[AB] && row2[AJ] &&
                    row3 && row3[AA] && row3[AB] && row3[AJ] &&
                    row4 && row4[AA] && row4[AB] && row4[AJ]) {
                    
                    // Verify rows 1&2 are same team and rows 3&4 are same team
                    if (row1[AB] === row2[AB] && row3[AB] === row4[AB] && row1[AB] !== row3[AB]) {
                        const teamNames = Object.keys(result.captains);
                        const team1 = teamNames[0];
                        const team2 = teamNames[1];
                        
                        // Determine which rows belong to which team
                        const team1Rows = row1[AB].toLowerCase().includes(team1) ? [row1, row2] : [row3, row4];
                        const team2Rows = row1[AB].toLowerCase().includes(team1) ? [row3, row4] : [row1, row2];
                        
                        // Get result from first player of team1
                        const team1Result = team1Rows[0][AJ];
                        const winner = team1Result === 'W' ? team1 : team1Result === 'L' ? team2 : '';
                        
                        bestBallMatches.push({
                            match: bestBallMatches.length + 1,
                            [team1]: [team1Rows[0][AA], team1Rows[1][AA]],
                            [team2]: [team2Rows[0][AA], team2Rows[1][AA]],
                            result: team1Result,
                            score: formatMatchScore(team1Rows[0][AE], team1Rows[0][AF]),
                            winner: winner
                        });
                    }
                }
                
                // Skip 5 rows (4 player rows + 1 gap row)
                rowIndex += 5;
            }
            
            result.bestBallResults = bestBallMatches;
            
            // Parse Singles matches from columns AL-AU (indices 37-46)
            // Pattern: Row 2 vs Row 3, skip row 4, Row 5 vs Row 6, etc.
            const singlesMatches = [];
            
            // Column indices for Singles data (AL-AU = indices 37-46)
            const AL = 37; // Player
            const AM = 38; // Team
            const AP = 41; // Net Holes Won/Lost
            const AQ = 42; // Holes Left
            const AU = 46; // Result
            
            console.log(`\nParsing singles matches for ${year}...`);
            console.log(`Captain row: ${captainRow}`);
            
            // Process matches in pairs of 2 rows with 1 row gap
            rowIndex = 1; // Reset for Singles, start at row 2
            let matchCount = 0;
            const expectedMatches = year === '2024' ? 14 : 12; // 28 players in 2024, 24 in other years
            
            // Don't limit to captainRow for singles - they may extend beyond
            while (rowIndex + 1 < rawData.length && matchCount < expectedMatches) {
                const row1 = rawData[rowIndex];
                const row2 = rawData[rowIndex + 1];
                
                // Debug logging for first few matches
                if (matchCount < 3) {
                    console.log(`\nChecking singles rows ${rowIndex} and ${rowIndex + 1}:`);
                    console.log(`Row ${rowIndex}: Player=${row1?.[AL]}, Team=${row1?.[AM]}, Result=${row1?.[AU]}`);
                    console.log(`Row ${rowIndex + 1}: Player=${row2?.[AL]}, Team=${row2?.[AM]}, Result=${row2?.[AU]}`);
                }
                
                // Check if we have valid singles data in these rows
                if (row1 && row1[AL] && row1[AM] && row1[AU] &&
                    row2 && row2[AL] && row2[AM] && row2[AU]) {
                    
                    // Verify they are on different teams
                    if (row1[AM] !== row2[AM]) {
                        matchCount++;
                        const teamNames = Object.keys(result.captains);
                        const team1 = teamNames[0];
                        const team2 = teamNames[1];
                        
                        // Determine which player is on which team
                        const team1Player = row1[AM].toLowerCase().includes(team1) ? row1[AL] : row2[AL];
                        const team2Player = row1[AM].toLowerCase().includes(team1) ? row2[AL] : row1[AL];
                        const team1Row = row1[AM].toLowerCase().includes(team1) ? row1 : row2;
                        
                        // Get result from team1's perspective
                        const team1Result = team1Row[AU];
                        const winner = team1Result === 'W' ? team1 : team1Result === 'L' ? team2 : '';
                        
                        singlesMatches.push({
                            match: singlesMatches.length + 1,
                            [team1]: team1Player,
                            [team2]: team2Player,
                            result: team1Result,
                            score: formatMatchScore(team1Row[AP], team1Row[AQ]),
                            winner: winner
                        });
                    }
                }
                
                // Skip 3 rows (2 player rows + 1 gap row)
                rowIndex += 3;
            }
            
            result.singlesResults = singlesMatches;
            console.log(`Found ${singlesMatches.length} singles matches for ${year}`);
            
            // Calculate daily scores
            let team1Scramble = 0, team2Scramble = 0;
            let team1BestBall = 0, team2BestBall = 0;
            let team1Singles = 0, team2Singles = 0;
            
            const teamNames = Object.keys(result.captains);
            
            scrambleMatches.forEach(match => {
                if (match.winner === teamNames[0]) team1Scramble++;
                else if (match.winner === teamNames[1]) team2Scramble++;
                else { team1Scramble += 0.5; team2Scramble += 0.5; }
            });
            
            bestBallMatches.forEach(match => {
                if (match.winner === teamNames[0]) team1BestBall++;
                else if (match.winner === teamNames[1]) team2BestBall++;
                else { team1BestBall += 0.5; team2BestBall += 0.5; }
            });
            
            singlesMatches.forEach(match => {
                if (match.winner === teamNames[0]) team1Singles++;
                else if (match.winner === teamNames[1]) team2Singles++;
                else { team1Singles += 0.5; team2Singles += 0.5; }
            });
            
            result.dailyScores.friday[teamNames[0]] = team1Scramble;
            result.dailyScores.friday[teamNames[1]] = team2Scramble;
            result.dailyScores.saturday[teamNames[0]] = team1BestBall;
            result.dailyScores.saturday[teamNames[1]] = team2BestBall;
            result.dailyScores.sunday[teamNames[0]] = team1Singles;
            result.dailyScores.sunday[teamNames[1]] = team2Singles;
            
            return result;
        }

        function formatMatchScore(holesWon, holesLeft) {
            if (holesWon && holesLeft) {
                return `${Math.abs(holesWon)}&${holesLeft}`;
            } else if (!holesWon || holesWon == 0) {
                return 'Halved';
            }
            return '';
        }

        // Helper functions
        function formatScore(upDown, left) {
            if (upDown && left) {
                return `${Math.abs(upDown)}&${left}`;
            } else if (upDown === 0) {
                return 'Halved';
            }
            return '';
        }

        function getYearDate(year) {
            const dates = {
                '2025': 'January 17-19, 2025',
                '2024': 'January 19-21, 2024',
                '2023': 'January 20-22, 2023',
                '2022': 'January 21-23, 2022',
                '2021': 'January 22-24, 2021',
                '2020': 'September 11-13, 2020',
                '2019': 'January 2019',
                '2018': 'January 2018'
            };
            return dates[year] || '';
        }

        function getYearCaptains(year) {
            const captains = {
                '2025': { pardo: "Lawrence Pardo", salas: "Javi Salas" },
                '2024': { victor: "Victor Garcia", carlos: "Carlos Enjamio" },
                '2023': { stu: "Stuart Briggle", wes: "Wes Briggle" },
                '2022': { jo: "Jo Noy", shawn: "Shawn Noy" },
                '2021': { danny: "Danny Yanez", mario: "Mario Martinez" },
                '2020': { vic: "Victor Riobueno", javi: "Javi Vargas" },
                '2019': { al: "Alex Lastra", skip: "Skippy Ramirez" },
                '2018': { portal: "Javi Portal", pete: "Pete Cabrera" }
            };
            return captains[year] || {};
        }

        function getYearScore(year) {
            const scores = {
                '2025': '15.5-8.5',
                '2024': '15-13',
                '2023': '13-11',
                '2022': '12.5-11.5',
                '2021': '15.5-8.5',
                '2020': '15-9',
                '2019': '9-7',
                '2018': '9-7'
            };
            return scores[year] || '';
        }

        function getYearCourses(year) {
            const courses = {
                '2025': {
                    scramble: { name: "Reunion Palmer (Gold)", rating: 70.9, slope: 133 },
                    bestBall: { name: "Disney's Magnolia (White)", rating: 71.6, slope: 130 },
                    singles: { name: "Waldorf Astoria (Blue/White)", rating: 71.7, slope: 137 }
                },
                '2024': {
                    scramble: { name: "Reunion Palmer (Gold)", rating: 70.9, slope: 133 },
                    bestBall: { name: "OC National Panther Lake", rating: 71.2, slope: 132 },
                    singles: { name: "Champions Gate Int'l (Blue)", rating: 73.0, slope: 132 }
                },
                // Add more years as needed
            };
            return courses[year] || { scramble: {}, bestBall: {}, singles: {} };
        }

        // Fallback function to restore hardcoded data if Excel fails
        function loadFallbackData() {
            console.log('Loading fallback data...');
            
            // Restore hardcoded tournament data
            tournamentData.years = {
                2025: { winner: "Pardo", loser: "Salas", score: "15.5-8.5", captains: { Pardo: "Lawrence Pardo", Salas: "Javi Salas" } },
                2024: { winner: "Victor", loser: "Carlos", score: "15-13", captains: { Victor: "Victor Garcia", Carlos: "Carlos Enjamio" } },
                2023: { winner: "Stu", loser: "Wes", score: "13-11", captains: { Stu: "Stuart Briggle", Wes: "Wes Briggle" } },
                2022: { winner: "Jo", loser: "Shawn", score: "12.5-11.5", captains: { Jo: "Jo Noy", Shawn: "Shawn Noy" } },
                2021: { winner: "Danny", loser: "Mario", score: "15.5-8.5", captains: { Danny: "Danny Yanez", Mario: "Mario Martinez" } },
                2020: { winner: "Vic", loser: "Javi", score: "15-9", captains: { Vic: "Victor Riobueno", Javi: "Javi Vargas" } },
                2019: { winner: "Al", loser: "Skip", score: "9-7", captains: { Al: "Alex Lastra", Skip: "Skippy Ramirez" } },
                2018: { winner: "Portal", loser: "Pete", score: "9-7", captains: { Portal: "Javi Portal", Pete: "Pete Cabrera" } }
            };
            
            // Set some basic player data
            tournamentData.players = [
                { rank: 1, name: "Danny Yanez", crs: 8, wins: 20, losses: 11, ties: 1, rating: 1.82, perfectAttendance: true },
                { rank: 2, name: "Jordan Portal", crs: 7, wins: 14, losses: 6, ties: 1, rating: 2.33, perfectAttendance: false }
            ];
            
            // Create a basic playerList
            window.playerList = ["Danny Yanez", "Jordan Portal", "Javi Portal", "Carlos Enjamio", "Victor Riobueno"];
            
            // Initialize handicap data with fallback values
            initializeHandicapData();
            
            // Initialize the app with fallback data
            showTab('2025');
            displayRandomStat();
        }

        // Load Excel data when page loads
        window.addEventListener('load', () => {
            console.log('Window loaded, starting Excel data load...');
            loadExcelData();
        });
        
        // Also try DOMContentLoaded as backup
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM ready');
            // Hide loading message if Excel doesn't load after timeout
            setTimeout(() => {
                const loadingDiv = document.querySelector('.loading');
                if (loadingDiv && loadingDiv.textContent === 'Loading tournament data...') {
                    console.error('Excel data failed to load after 5 seconds, loading fallback...');
                    loadFallbackData();
                }
            }, 5000);
        });

        // Temporary hardcoded data for fallback
        const matchDataFallback = {
            2025: {
                date: "January 17-19, 2025",
                courses: {
                    scramble: { name: "Reunion Palmer (Gold)", rating: 70.9, slope: 133 },
                    bestBall: { name: "Disney's Magnolia (White)", rating: 71.6, slope: 130 },
                    singles: { name: "Waldorf Astoria (Blue/White)", rating: 71.7, slope: 137 }
                },
                captains: { pardo: "Lawrence Pardo", salas: "Javi Salas" },
                finalScore: "15.5-8.5",
                teamPardo: ["Lawrence Pardo", "Javi Portal", "Alex Lastra", "Michael Quintana", "Danny Yanez", "Jo Noy", "Roger De Armas", "Jordan Portal", "Skippy Ramirez", "Andrew Guasch", "Javi Vargas", "Eric Diaz"],
                teamSalas: ["Javi Salas", "Pete Cabrera", "Carlos Alfonso", "Boogie Lastra", "Victor Riobueno", "Mario Martinez", "Carlos Enjamio", "David Del Cristo", "Shawn Noy", "Mauricio Restrepo", "Stefano Diaz", "Joey Pinto"],
                scrambleResults: [
                    { match: 1, pardo: ["Pardo", "Quintana"], salas: ["Salas", "Enjamio"], result: "W", score: "2&1", pardoScore: 1, salasScore: 0 },
                    { match: 2, pardo: ["J. Portal", "Jo. Portal"], salas: ["Alfonso", "Cabrera"], result: "W", score: "3&2", pardoScore: 1, salasScore: 0 },
                    { match: 3, pardo: ["Yanez", "Noy"], salas: ["B. Lastra", "Riobueno"], result: "L", score: "2&1", pardoScore: 0, salasScore: 1 },
                    { match: 4, pardo: ["A. Lastra", "Vargas"], salas: ["Martinez", "S. Diaz"], result: "W", score: "3&2", pardoScore: 1, salasScore: 0 },
                    { match: 5, pardo: ["Guasch", "De Armas"], salas: ["Del Cristo", "Restrepo"], result: "W", score: "4&3", pardoScore: 1, salasScore: 0 },
                    { match: 6, pardo: ["Ramirez", "E. Diaz"], salas: ["S. Noy", "Pinto"], result: "W", score: "5&4", pardoScore: 1, salasScore: 0 }
                ],
                bestBallResults: [
                    { match: 1, pardo: ["Pardo", "Yanez"], salas: ["Enjamio", "Salas"], result: "W", score: "1 up", pardoScore: 1, salasScore: 0 },
                    { match: 2, pardo: ["J. Portal", "Jo. Portal"], salas: ["Cabrera", "Alfonso"], result: "W", score: "4&3", pardoScore: 1, salasScore: 0 },
                    { match: 3, pardo: ["Quintana", "Noy"], salas: ["Riobueno", "Martinez"], result: "W", score: "3&2", pardoScore: 1, salasScore: 0 },
                    { match: 4, pardo: ["A. Lastra", "Vargas"], salas: ["B. Lastra", "S. Diaz"], result: "W", score: "3&2", pardoScore: 1, salasScore: 0 },
                    { match: 5, pardo: ["Guasch", "De Armas"], salas: ["Del Cristo", "Restrepo"], result: "L", score: "1 up", pardoScore: 0, salasScore: 1 },
                    { match: 6, pardo: ["Ramirez", "E. Diaz"], salas: ["S. Noy", "Pinto"], result: "T", score: "Halved", pardoScore: 0.5, salasScore: 0.5 }
                ],
                singlesResults: [
                    { match: 1, pardo: "Jordan Portal", salas: "Stefano Diaz", result: "W", score: "6&4", pardoScore: 1, salasScore: 0 },
                    { match: 2, pardo: "Danny Yanez", salas: "Carlos Enjamio", result: "W", score: "3&2", pardoScore: 1, salasScore: 0 },
                    { match: 3, pardo: "Javi Portal", salas: "Pete Cabrera", result: "T", score: "Halved", pardoScore: 0.5, salasScore: 0.5 },
                    { match: 4, pardo: "Alex Lastra", salas: "Carlos Alfonso", result: "W", score: "6&5", pardoScore: 1, salasScore: 0 },
                    { match: 5, pardo: "Michael Quintana", salas: "Victor Riobueno", result: "L", score: "4&3", pardoScore: 0, salasScore: 1 },
                    { match: 6, pardo: "Jo Noy", salas: "Boogie Lastra", result: "L", score: "1 up", pardoScore: 0, salasScore: 1 },
                    { match: 7, pardo: "Lawrence Pardo", salas: "Javi Salas", result: "W", score: "2&1", pardoScore: 1, salasScore: 0 }
                ],
                dailyScores: {
                    friday: { pardo: 5, salas: 1 },
                    saturday: { pardo: 4.5, salas: 1.5 },
                    sunday: { pardo: 4.5, salas: 2.5 }
                }
            },
            2024: {
                date: "January 19-21, 2024",
                courses: {
                    scramble: { name: "Reunion Palmer (Gold)", rating: 70.9, slope: 133 },
                    bestBall: { name: "OC National Panther Lake", rating: 71.2, slope: 132 },
                    singles: { name: "Champions Gate Int'l (Blue)", rating: 73.0, slope: 132 }
                },
                captains: { victor: "Victor Garcia", carlos: "Carlos Enjamio" },
                finalScore: "15-13",
                teamVictor: ["Victor Garcia", "Danny Yanez", "Javi Portal", "Jordan Portal", "Jo Noy", "Alex Lastra", "Mauricio Restrepo", "Luis Sandoval", "Roger De Armas", "Andrew Guasch", "Mikey Newmeyer", "Javi Vargas", "Eric Diaz", "Mike Socarras"],
                teamCarlos: ["Carlos Enjamio", "Pete Cabrera", "Victor Riobueno", "Lawrence Pardo", "Javi Salas", "Michael Quintana", "Boogie Lastra", "Carlos Alfonso", "Ernesto Ibanez", "David Del Cristo", "Shawn Noy", "Ricky Escobar", "Stefano Diaz", "Kevin Samlut"],
                dailyScores: {
                    friday: { victor: 3.5, carlos: 2.5 },
                    saturday: { victor: 5.5, carlos: 4.5 },
                    sunday: { victor: 6, carlos: 6 }
                }
            },
            2023: {
                date: "January 20-22, 2023",
                courses: {
                    scramble: { name: "Reunion Nicklaus (Blue)", rating: 71.4, slope: 133 },
                    bestBall: { name: "Grand Cypress Links (Blue)", rating: 70.4, slope: 117 },
                    singles: { name: "Celebration (Gold)", rating: 72.1, slope: 135 }
                },
                captains: { stu: "Stuart Briggle", wes: "Wes Briggle" },
                finalScore: "13-11",
                dailyScores: {
                    friday: { stu: 4, wes: 2 },
                    saturday: { stu: 4, wes: 4 },
                    sunday: { stu: 5, wes: 5 }
                }
            },
            2022: {
                date: "January 21-23, 2022",
                courses: {
                    scramble: { name: "Royal St. Cloud", rating: 70.9, slope: 126 },
                    bestBall: { name: "Reunion Watson (Blue)", rating: 70.8, slope: 126 },
                    singles: { name: "Reunion Nicklaus (Blue)", rating: 71.4, slope: 133 }
                },
                captains: { jo: "Jo Noy", shawn: "Shawn Noy" },
                finalScore: "12.5-11.5",
                dailyScores: {
                    friday: { jo: 4, shawn: 2 },
                    saturday: { jo: 3, shawn: 5 },
                    sunday: { jo: 5.5, shawn: 4.5 }
                }
            },
            2021: {
                date: "January 22-24, 2021",
                courses: {
                    scramble: { name: "Disney's Magnolia", rating: 69.6, slope: 126 },
                    bestBall: { name: "Disney's Palm (Gold)", rating: 68.7, slope: 124 },
                    singles: { name: "Southern Dunes (White)", rating: 70.4, slope: 133 }
                },
                captains: { danny: "Danny Yanez", mario: "Mario Martinez" },
                finalScore: "15.5-8.5",
                dailyScores: {
                    friday: { danny: 5, mario: 1 },
                    saturday: { danny: 5, mario: 3 },
                    sunday: { danny: 5.5, mario: 4.5 }
                }
            },
            2020: {
                date: "September 11-13, 2020",
                courses: {
                    scramble: { name: "West Palm Beach Par 3", rating: 52.9, slope: 113 },
                    bestBall: { name: "Abacoa Golf Club (White)", rating: 70.2, slope: 132 },
                    singles: { name: "Trump Doral Red Tiger (Gold)", rating: 69.6, slope: 132 }
                },
                captains: { vic: "Victor Riobueno", javi: "Javi Vargas" },
                finalScore: "15-9"
            },
            2019: {
                date: "January 2019",
                captains: { al: "Alex Lastra", skip: "Skippy Ramirez" },
                finalScore: "9-7"
            },
            2018: {
                date: "January 2018",
                captains: { portal: "Javi Portal", pete: "Pete Cabrera" },
                finalScore: "9-7"
            }
        };

        // Complete player handicap progression data (will be loaded from Excel)
        const handicapDataFallback = {
            // Core players with complete data
            "Danny Yanez": { 2018: 16, 2019: 14, 2020: 12, 2021: 10, 2022: 14.1, 2023: 11.9, 2024: 12, 2025: 8 },
            "Jordan Portal": { 2018: 0.5, 2019: 0, 2020: 0, 2021: 0, 2022: 0, 2023: 1.4, 2024: 1, 2025: 3.1 },
            "Javi Portal": { 2018: 0, 2019: 0, 2020: 0.5, 2021: 0.5, 2022: 0.1, 2023: 0, 2024: 1.2, 2025: 1.5 },
            "Carlos Enjamio": { 2018: 25, 2019: 22, 2020: 20, 2021: 18, 2022: 18.3, 2023: 18.3, 2024: 16, 2025: 13.3 },
            "Victor Riobueno": { 2018: 22.1, 2019: 20, 2020: 19, 2021: 17.5, 2022: 17.7, 2023: 16.5, 2024: 16.6, 2025: 14.4 },
            "Pete Cabrera": { 2018: 8, 2019: 7.5, 2020: 7, 2021: 6.5, 2022: 7, 2023: 8, 2024: 8, 2025: 6.1 },
            
            // Players with partial data
            "Alex Lastra": { 2018: 26.5, 2019: 26, 2020: 25.5, 2021: 25, 2022: 24.5, 2023: 24.8, 2024: 20.5 },
            "Lawrence Pardo": { 2019: 23, 2020: 21, 2021: 19, 2022: 18, 2023: 18, 2024: 16.3, 2025: 17.2 },
            "Michael Quintana": { 2020: 16, 2021: 15, 2022: 18, 2023: 18, 2024: 17, 2025: 17 },
            "Jo Noy": { 2020: 16, 2021: 15, 2022: 20.5, 2023: 20.5, 2024: 12, 2025: 11.5 },
            "Shawn Noy": { 2021: 20, 2022: 16, 2023: 16, 2024: 18, 2025: 17.5 },
            "Boogie Lastra": { 2021: 28, 2022: 26, 2023: 27.9, 2024: 23.1, 2025: 22.8 },
            "Carlos Alfonso": { 2021: 20, 2022: 20, 2023: 20.6, 2024: 22.6, 2025: 16.5 },
            "Stefano Diaz": { 2024: 2.5, 2025: 0.5 },
            "Andrew Guasch": { 2023: 12, 2024: 13, 2025: 9 },
            "Javi Vargas": { 2019: 20, 2020: 19.5, 2021: 19, 2022: 24, 2023: 24, 2024: 29, 2025: 17 },
            "Mario Martinez": { 2021: 10, 2022: 11.9, 2023: 11.9, 2024: 8.5 },
            "David Del Cristo": { 2021: 25, 2022: 27, 2023: 27, 2024: 22 },
            "Eric Diaz": { 2022: 26.5, 2023: 23, 2024: 24, 2025: 24 },
            "Mauricio Restrepo": { 2020: 30, 2021: 28, 2022: 22.3, 2023: 22.3, 2024: 24.8, 2025: 25 },
            "Roger De Armas": { 2024: 20.3, 2025: 19 },
            "Luis Sandoval": { 2023: 21, 2024: 17, 2025: 15 },
            "Kevin Samlut": { 2022: 25.6, 2023: 25.6, 2024: 25, 2025: 24 },
            "Ricky Escobar": { 2022: 18, 2023: 0, 2024: 0, 2025: 15 },
            "Joey Pinto": { 2024: 16, 2025: 15 },
            "Javi Salas": { 2022: 16.4, 2023: 16.2, 2024: 10, 2025: 12 },
            "Victor Garcia": { 2022: 25, 2023: 23, 2024: 19, 2025: 19 },
            "Stuart Briggle": { 2022: 18.9, 2023: 17, 2024: 13.8 },
            "Wes Briggle": { 2022: 20.7, 2023: 20, 2024: 17 },
            "Matt Barkett": { 2022: 15.9, 2023: 15.9 },
            "Salo Iza": { 2025: 8.9 },
            "Mikey Newmeyer": { 2024: 13.5, 2025: 13.5 },
            "Mauricio Baca": { 2025: 24 },
            "Robert Vazquez": { 2025: 23 },
            "Mooser Rodriguez": { 2023: 38, 2025: 37 },
            "Augie De Goytisolo": { 2018: 22, 2019: 22, 2020: 22, 2021: 22, 2022: 22, 2023: 22, 2024: 22, 2025: 22 },
            
            // Players with estimated handicaps (no data from 2022-2025)
            "Skippy Ramirez": { 2018: 36, 2019: 36, 2020: 36, 2025: 16 },
            "CJ Osbourne": { 2019: 15 },
            "Brendan Areces": { 2020: 36, 2021: 36 },
            
            // Other players with limited data
            "Alex Uribarri": { 2022: 15, 2023: 15 },
            "Ernesto Ibanez": { 2022: 40, 2023: 40, 2024: 29.2 },
            "Peter Endejan": { 2022: 36, 2023: 36 },
            "Andrew Areces": { 2024: 31 }
        };

        // Head-to-head records
        const headToHeadData = {};

        // Calculate head-to-head from match data
        function calculateHeadToHead() {
            // This would process all match data to build H2H records
            // Implementation would go through each year's results
        }

        // List of captain nicknames to filter out from stats
        const captainNicknames = ['pardo', 'salas', 'victor', 'carlos', 'stu', 'wes', 'jo', 'shawn', 
                                  'danny', 'mario', 'vic', 'javi', 'al', 'skip', 'portal', 'pete'];

        // Advanced Analytics Functions
        // Calculate ACTUAL strength of schedule
        function calculateStrengthOfSchedule() {
            const sosData = {};
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                // Process singles matches - easiest to track individual opponents
                yearData.singlesResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const player1 = match[captains[0]];
                    const player2 = match[captains[1]];
                    
                    if (player1 && player2 && player1 !== player2 && 
                        !captainNicknames.includes(player1.toLowerCase()) && 
                        !captainNicknames.includes(player2.toLowerCase())) {
                        // Get actual handicaps for that year
                        const hcp1 = handicapData[player1]?.[year] || null;
                        const hcp2 = handicapData[player2]?.[year] || null;
                        
                        if (hcp1 !== null && hcp2 !== null) {
                            // Track opponent handicaps
                            if (!sosData[player1]) sosData[player1] = { opponents: [], totalHcp: 0, count: 0 };
                            if (!sosData[player2]) sosData[player2] = { opponents: [], totalHcp: 0, count: 0 };
                            
                            sosData[player1].opponents.push({ name: player2, hcp: hcp2, year });
                            sosData[player1].totalHcp += hcp2;
                            sosData[player1].count++;
                            
                            sosData[player2].opponents.push({ name: player1, hcp: hcp1, year });
                            sosData[player2].totalHcp += hcp1;
                            sosData[player2].count++;
                        }
                    }
                });
            });
            
            // Calculate averages
            Object.keys(sosData).forEach(player => {
                sosData[player].avgOpponentHcp = sosData[player].totalHcp / sosData[player].count;
                // Find toughest and easiest opponents
                sosData[player].opponents.sort((a, b) => a.hcp - b.hcp);
                sosData[player].toughestOpponent = sosData[player].opponents[0];
                sosData[player].easiestOpponent = sosData[player].opponents[sosData[player].opponents.length - 1];
            });
            
            return sosData;
        }

        function calculateClutchRating(playerName) {
            const clutchData = {
                closeMatches: { W: 0, L: 0, T: 0 },
                decisiveMatches: { W: 0, L: 0, T: 0 },
                sundayMatches: { W: 0, L: 0, T: 0 },
                comebacks: 0
            };
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                // Singles matches are best for individual clutch rating
                yearData.singlesResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const player1 = match[captains[0]];
                    const player2 = match[captains[1]];
                    
                    if (player1 === playerName || player2 === playerName) {
                        const isPlayer1 = player1 === playerName;
                        const opponent = isPlayer1 ? player2 : player1;
                        
                        // Check if close match (1 up, 2&1, or halved)
                        const score = match.score?.toLowerCase() || '';
                        const isClose = score.includes('1 up') || score.includes('2&1') || 
                                      score.includes('halved') || score.includes('19');
                        
                        if (isClose) {
                            if (match.winner === captains[isPlayer1 ? 0 : 1]) {
                                clutchData.closeMatches.W++;
                            } else if (match.winner === captains[isPlayer1 ? 1 : 0]) {
                                clutchData.closeMatches.L++;
                            } else {
                                clutchData.closeMatches.T++;
                            }
                        }
                        
                        // Check if Sunday match (higher pressure)
                        if (match.day === 'sunday') {
                            if (match.winner === captains[isPlayer1 ? 0 : 1]) {
                                clutchData.sundayMatches.W++;
                            } else if (match.winner === captains[isPlayer1 ? 1 : 0]) {
                                clutchData.sundayMatches.L++;
                            } else {
                                clutchData.sundayMatches.T++;
                            }
                        }
                    }
                });
            });
            
            // Calculate clutch rating
            const closeTotal = clutchData.closeMatches.W + clutchData.closeMatches.L + clutchData.closeMatches.T;
            const sundayTotal = clutchData.sundayMatches.W + clutchData.sundayMatches.L + clutchData.sundayMatches.T;
            
            const closeWinRate = closeTotal > 0 ? (clutchData.closeMatches.W / closeTotal) : 0;
            const sundayWinRate = sundayTotal > 0 ? (clutchData.sundayMatches.W / sundayTotal) : 0;
            
            return {
                closeMatchRecord: `${clutchData.closeMatches.W}-${clutchData.closeMatches.L}-${clutchData.closeMatches.T}`,
                clutchRating: ((closeWinRate * 0.6 + sundayWinRate * 0.4) * 100).toFixed(1),
                pressureWinRate: sundayWinRate * 100,
                closeWinRate: closeWinRate * 100
            };
        }

        // Calculate team chemistry - which pairings win together
        function calculateTeamChemistry() {
            const pairings = {};
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                // Scrambles
                yearData.scrambleResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const team1Players = match[captains[0]];
                    const team2Players = match[captains[1]];
                    
                    if (team1Players?.length === 2) {
                        const pairKey = team1Players.sort().join(' & ');
                        if (!pairings[pairKey]) pairings[pairKey] = { W: 0, L: 0, T: 0, format: 'Scramble' };
                        
                        if (match.winner === captains[0]) pairings[pairKey].W++;
                        else if (match.winner === captains[1]) pairings[pairKey].L++;
                        else pairings[pairKey].T++;
                    }
                    
                    if (team2Players?.length === 2) {
                        const pairKey = team2Players.sort().join(' & ');
                        if (!pairings[pairKey]) pairings[pairKey] = { W: 0, L: 0, T: 0, format: 'Scramble' };
                        
                        if (match.winner === captains[1]) pairings[pairKey].W++;
                        else if (match.winner === captains[0]) pairings[pairKey].L++;
                        else pairings[pairKey].T++;
                    }
                });
                
                // Best Ball
                yearData.bestBallResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const team1Players = match[captains[0]];
                    const team2Players = match[captains[1]];
                    
                    if (team1Players?.length === 2) {
                        const pairKey = team1Players.sort().join(' & ');
                        if (!pairings[pairKey]) pairings[pairKey] = { W: 0, L: 0, T: 0, format: 'Best Ball' };
                        
                        if (match.winner === captains[0]) pairings[pairKey].W++;
                        else if (match.winner === captains[1]) pairings[pairKey].L++;
                        else pairings[pairKey].T++;
                    }
                    
                    if (team2Players?.length === 2) {
                        const pairKey = team2Players.sort().join(' & ');
                        if (!pairings[pairKey]) pairings[pairKey] = { W: 0, L: 0, T: 0, format: 'Best Ball' };
                        
                        if (match.winner === captains[1]) pairings[pairKey].W++;
                        else if (match.winner === captains[0]) pairings[pairKey].L++;
                        else pairings[pairKey].T++;
                    }
                });
            });
            
            // Calculate win rates
            Object.keys(pairings).forEach(pair => {
                const stats = pairings[pair];
                const total = stats.W + stats.L + stats.T;
                stats.winRate = total > 0 ? (stats.W / total * 100).toFixed(1) : 0;
                stats.total = total;
            });
            
            return pairings;
        }

        // Head-to-head records
        function calculateHeadToHead() {
            const h2h = {};
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                yearData.singlesResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const player1 = match[captains[0]];
                    const player2 = match[captains[1]];
                    
                    if (player1 && player2 && player1 !== player2 &&
                        !captainNicknames.includes(player1.toLowerCase()) && 
                        !captainNicknames.includes(player2.toLowerCase())) {
                        const key = [player1, player2].sort().join(' vs ');
                        if (!h2h[key]) h2h[key] = { 
                            player1: [player1, player2].sort()[0], 
                            player2: [player1, player2].sort()[1],
                            player1Wins: 0,
                            player2Wins: 0,
                            ties: 0,
                            matches: []
                        };
                        
                        const record = h2h[key];
                        const sortedPlayers = [player1, player2].sort();
                        
                        if (match.winner === captains[0] && player1 === match[captains[0]]) {
                            if (player1 === sortedPlayers[0]) record.player1Wins++;
                            else record.player2Wins++;
                        } else if (match.winner === captains[1] && player2 === match[captains[1]]) {
                            if (player2 === sortedPlayers[0]) record.player1Wins++;
                            else record.player2Wins++;
                        } else {
                            record.ties++;
                        }
                        
                        record.matches.push({
                            year,
                            winner: match.winner,
                            score: match.score
                        });
                    }
                });
            });
            
            return h2h;
        }

        function calculateCoursePerformance() {
            const courseStats = {};
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                const course = yearData.course || 'Unknown';
                if (!courseStats[course]) {
                    courseStats[course] = {
                        players: {},
                        teamRecords: {},
                        formatPerformance: { singles: {}, scramble: {}, bestBall: {} }
                    };
                }
                
                // Track individual performance by course
                ['singlesResults', 'scrambleResults', 'bestBallResults'].forEach(format => {
                    yearData[format]?.forEach(match => {
                        const captains = Object.keys(yearData.captains || {});
                        const formatType = format.replace('Results', '');
                        
                        if (format === 'singlesResults') {
                            const player1 = match[captains[0]];
                            const player2 = match[captains[1]];
                            
                            [player1, player2].forEach(player => {
                                if (player && !captainNicknames.includes(player.toLowerCase())) {
                                    if (!courseStats[course].players[player]) {
                                        courseStats[course].players[player] = { W: 0, L: 0, T: 0 };
                                    }
                                    
                                    if (match.winner?.includes(player)) {
                                        courseStats[course].players[player].W++;
                                    } else if (match.winner && !match.winner.includes(player)) {
                                        courseStats[course].players[player].L++;
                                    } else {
                                        courseStats[course].players[player].T++;
                                    }
                                }
                            });
                        }
                        
                        // Track team performance by course
                        captains.forEach(captain => {
                            if (!courseStats[course].teamRecords[captain]) {
                                courseStats[course].teamRecords[captain] = { W: 0, L: 0, T: 0 };
                            }
                        });
                        
                        if (match.winner) {
                            courseStats[course].teamRecords[match.winner].W++;
                            const loser = captains.find(c => c !== match.winner);
                            if (loser) courseStats[course].teamRecords[loser].L++;
                        } else {
                            captains.forEach(captain => {
                                courseStats[course].teamRecords[captain].T++;
                            });
                        }
                    });
                });
            });
            
            // Calculate win rates
            Object.keys(courseStats).forEach(course => {
                Object.keys(courseStats[course].players).forEach(player => {
                    const stats = courseStats[course].players[player];
                    const total = stats.W + stats.L + stats.T;
                    stats.winRate = total > 0 ? (stats.W / total * 100).toFixed(1) : 0;
                    stats.total = total;
                });
                
                Object.keys(courseStats[course].teamRecords).forEach(team => {
                    const stats = courseStats[course].teamRecords[team];
                    const total = stats.W + stats.L + stats.T;
                    stats.winRate = total > 0 ? (stats.W / total * 100).toFixed(1) : 0;
                    stats.total = total;
                });
            });
            
            return courseStats;
        }

        function calculateRevengeRate() {
            const revengeData = {};
            const matchHistory = {};
            
            // First pass: build match history
            const allMatches = [];
            Object.entries(matchData).forEach(([year, yearData]) => {
                yearData.singlesResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const player1 = match[captains[0]];
                    const player2 = match[captains[1]];
                    
                    if (player1 && player2 && !captainNicknames.includes(player1.toLowerCase()) && 
                        !captainNicknames.includes(player2.toLowerCase())) {
                        allMatches.push({
                            year: parseInt(year),
                            player1,
                            player2,
                            winner: match.winner,
                            score: match.score
                        });
                    }
                });
            });
            
            // Sort by year
            allMatches.sort((a, b) => a.year - b.year);
            
            // Track revenge opportunities
            allMatches.forEach(match => {
                const key = [match.player1, match.player2].sort().join(' vs ');
                if (!matchHistory[key]) {
                    matchHistory[key] = [];
                }
                
                const history = matchHistory[key];
                if (history.length > 0) {
                    const lastMatch = history[history.length - 1];
                    const lastWinner = lastMatch.winner?.includes(lastMatch.player1) ? lastMatch.player1 : lastMatch.player2;
                    const lastLoser = lastWinner === lastMatch.player1 ? lastMatch.player2 : lastMatch.player1;
                    const currentWinner = match.winner?.includes(match.player1) ? match.player1 : match.player2;
                    
                    if (!revengeData[lastLoser]) {
                        revengeData[lastLoser] = { opportunities: 0, revenges: 0, failed: 0 };
                    }
                    
                    revengeData[lastLoser].opportunities++;
                    if (currentWinner === lastLoser) {
                        revengeData[lastLoser].revenges++;
                    } else {
                        revengeData[lastLoser].failed++;
                    }
                }
                
                matchHistory[key].push(match);
            });
            
            // Calculate revenge rates
            Object.keys(revengeData).forEach(player => {
                const data = revengeData[player];
                data.revengeRate = data.opportunities > 0 ? 
                    (data.revenges / data.opportunities * 100).toFixed(1) : 0;
            });
            
            return revengeData;
        }

        function calculateMomentumScore() {
            const momentum = {
                fridayLeadHolds: { kept: 0, lost: 0 },
                saturdayLeadHolds: { kept: 0, lost: 0 },
                comebacks: [],
                biggestSwings: []
            };
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                if (yearData.dailyScores) {
                    const friday = yearData.dailyScores.friday || {};
                    const saturday = yearData.dailyScores.saturday || {};
                    const sunday = yearData.dailyScores.sunday || {};
                    
                    // Calculate cumulative scores
                    const captains = Object.keys(yearData.captains || {});
                    if (captains.length === 2) {
                        const team1 = captains[0];
                        const team2 = captains[1];
                        
                        // Friday to Saturday momentum
                        const fridayLeader = friday[team1] > friday[team2] ? team1 : 
                                           friday[team2] > friday[team1] ? team2 : null;
                        
                        if (fridayLeader) {
                            const satCumulative1 = (friday[team1] || 0) + (saturday[team1] || 0);
                            const satCumulative2 = (friday[team2] || 0) + (saturday[team2] || 0);
                            const satLeader = satCumulative1 > satCumulative2 ? team1 : team2;
                            
                            if (fridayLeader === satLeader) {
                                momentum.fridayLeadHolds.kept++;
                            } else {
                                momentum.fridayLeadHolds.lost++;
                                momentum.comebacks.push({
                                    year,
                                    team: satLeader,
                                    overcame: Math.abs(friday[team1] - friday[team2]),
                                    day: 'Saturday'
                                });
                            }
                        }
                        
                        // Saturday to Sunday momentum
                        const satCumulative1 = (friday[team1] || 0) + (saturday[team1] || 0);
                        const satCumulative2 = (friday[team2] || 0) + (saturday[team2] || 0);
                        const saturdayLeader = satCumulative1 > satCumulative2 ? team1 : 
                                             satCumulative2 > satCumulative1 ? team2 : null;
                        
                        if (saturdayLeader) {
                            const finalScore1 = satCumulative1 + (sunday[team1] || 0);
                            const finalScore2 = satCumulative2 + (sunday[team2] || 0);
                            const winner = finalScore1 > finalScore2 ? team1 : team2;
                            
                            if (saturdayLeader === winner) {
                                momentum.saturdayLeadHolds.kept++;
                            } else {
                                momentum.saturdayLeadHolds.lost++;
                                momentum.comebacks.push({
                                    year,
                                    team: winner,
                                    overcame: Math.abs(satCumulative1 - satCumulative2),
                                    day: 'Sunday'
                                });
                            }
                        }
                        
                        // Track biggest single-day swings
                        const satSwing = Math.abs((saturday[team1] || 0) - (saturday[team2] || 0));
                        const sunSwing = Math.abs((sunday[team1] || 0) - (sunday[team2] || 0));
                        
                        if (satSwing > 3) {
                            momentum.biggestSwings.push({
                                year,
                                day: 'Saturday',
                                points: satSwing,
                                winner: (saturday[team1] || 0) > (saturday[team2] || 0) ? team1 : team2
                            });
                        }
                        
                        if (sunSwing > 3) {
                            momentum.biggestSwings.push({
                                year,
                                day: 'Sunday',
                                points: sunSwing,
                                winner: (sunday[team1] || 0) > (sunday[team2] || 0) ? team1 : team2
                            });
                        }
                    }
                }
            });
            
            // Sort comebacks and swings by magnitude
            momentum.comebacks.sort((a, b) => b.overcame - a.overcame);
            momentum.biggestSwings.sort((a, b) => b.points - a.points);
            
            return momentum;
        }

        // Calculate strokes given in match based on handicaps and format
        // Note: Plus handicaps are positive numbers (e.g., +3.1 means 3.1 better than scratch)
        function calculateStrokesGiven(player1, player2, year, format) {
            const hcp1 = handicapData[player1] && handicapData[player1][year] || 0;
            const hcp2 = handicapData[player2] && handicapData[player2][year] || 0;
            
            if (format === 'scramble') {
                // In scramble, use team handicaps (35%/15% formula)
                // This is simplified - you'd need both team members
                return Math.abs(hcp1 - hcp2) * 0.35;
            } else if (format === 'singles') {
                return Math.abs(hcp1 - hcp2);
            }
            // Best ball uses full handicaps for both
            return Math.abs(hcp1 - hcp2);
        }

        // Analyze performance vs handicap expectation
        function analyzePerformanceVsHandicap() {
            const analysis = {
                byFormat: {
                    singles: {},
                    scramble: {},
                    bestBall: {}
                },
                biggestUpsets: [],
                upsetSpecialists: {}
            };
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                // Analyze singles
                yearData.singlesResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const player1 = match[captains[0]];
                    const player2 = match[captains[1]];
                    
                    if (player1 && player2 && !captainNicknames.includes(player1.toLowerCase()) && 
                        !captainNicknames.includes(player2.toLowerCase())) {
                        const hcp1 = handicapData[player1]?.[year] || null;
                        const hcp2 = handicapData[player2]?.[year] || null;
                        
                        if (hcp1 !== null && hcp2 !== null) {
                            const strokesGiven = Math.abs(hcp1 - hcp2);
                            const bucket = Math.floor(strokesGiven / 5) * 5;
                            
                            if (!analysis.byFormat.singles[bucket]) {
                                analysis.byFormat.singles[bucket] = { total: 0, upsets: 0, favorites: 0 };
                            }
                            
                            analysis.byFormat.singles[bucket].total++;
                            
                            const favorite = hcp1 < hcp2 ? player1 : player2;
                            const underdog = hcp1 < hcp2 ? player2 : player1;
                            const favoriteWon = match.winner?.includes(favorite);
                            
                            if (favoriteWon) {
                                analysis.byFormat.singles[bucket].favorites++;
                            } else if (match.winner?.includes(underdog)) {
                                analysis.byFormat.singles[bucket].upsets++;
                                
                                // Track biggest upsets
                                if (strokesGiven >= 10) {
                                    analysis.biggestUpsets.push({
                                        year,
                                        format: 'singles',
                                        winner: underdog,
                                        loser: favorite,
                                        strokesGiven,
                                        score: match.score
                                    });
                                }
                                
                                // Track upset specialists
                                if (!analysis.upsetSpecialists[underdog]) {
                                    analysis.upsetSpecialists[underdog] = { upsets: 0, asFavorite: 0, asUnderdog: 0 };
                                }
                                analysis.upsetSpecialists[underdog].upsets++;
                                analysis.upsetSpecialists[underdog].asUnderdog++;
                            }
                        }
                    }
                });
                
                // Analyze scrambles
                yearData.scrambleResults?.forEach(match => {
                    const captains = Object.keys(yearData.captains || {});
                    const team1Players = match[captains[0]];
                    const team2Players = match[captains[1]];
                    
                    if (team1Players?.length === 2 && team2Players?.length === 2) {
                        // Calculate team handicaps (simplified - would need proper scramble calculation)
                        const team1Hcp = team1Players.reduce((sum, p) => {
                            return sum + (handicapData[p]?.[year] || 0);
                        }, 0) / 2;
                        
                        const team2Hcp = team2Players.reduce((sum, p) => {
                            return sum + (handicapData[p]?.[year] || 0);
                        }, 0) / 2;
                        
                        const strokesGiven = Math.abs(team1Hcp - team2Hcp);
                        const bucket = Math.floor(strokesGiven / 5) * 5;
                        
                        if (!analysis.byFormat.scramble[bucket]) {
                            analysis.byFormat.scramble[bucket] = { total: 0, upsets: 0, favorites: 0 };
                        }
                        
                        analysis.byFormat.scramble[bucket].total++;
                        
                        const favoriteTeam = team1Hcp < team2Hcp ? captains[0] : captains[1];
                        if (match.winner === favoriteTeam) {
                            analysis.byFormat.scramble[bucket].favorites++;
                        } else if (match.winner) {
                            analysis.byFormat.scramble[bucket].upsets++;
                        }
                    }
                });
            });
            
            // Sort biggest upsets
            analysis.biggestUpsets.sort((a, b) => b.strokesGiven - a.strokesGiven);
            
            // Calculate upset rates
            Object.keys(analysis.byFormat).forEach(format => {
                Object.keys(analysis.byFormat[format]).forEach(bucket => {
                    const stats = analysis.byFormat[format][bucket];
                    stats.upsetRate = stats.total > 0 ? (stats.upsets / stats.total * 100).toFixed(1) : 0;
                    stats.favoriteRate = stats.total > 0 ? (stats.favorites / stats.total * 100).toFixed(1) : 0;
                });
            });
            
            return analysis;
        }

        function generateMeaningfulStats() {
            // Only return stats if we have data loaded
            if (!matchData || Object.keys(matchData).length === 0) {
                return "Loading match data...";
            }
            
            try {
                const teamChemistry = calculateTeamChemistry();
                const h2hRecords = calculateHeadToHead();
                const sos = calculateStrengthOfSchedule();
                const momentum = calculateMomentumScore();
                const upsetAnalysis = analyzePerformanceVsHandicap();
                const coursePerformance = calculateCoursePerformance();
                const revengeData = calculateRevengeRate();
                
                const insights = [];
                
                // Find best pairings
                const pairingsArray = Object.entries(teamChemistry)
                    .filter(([_, stats]) => stats.total >= 2)
                    .sort((a, b) => parseFloat(b[1].winRate) - parseFloat(a[1].winRate));
                
                if (pairingsArray.length > 0) {
                    const bestPair = pairingsArray[0];
                    insights.push(`Best pairing: <span class='stat-highlight'>${bestPair[0]}</span> win ${bestPair[1].winRate}% together (${bestPair[1].W}-${bestPair[1].L}-${bestPair[1].T})`);
                }
                
                // Find worst pairing (anti-chemistry)
                const worstPairings = pairingsArray
                    .filter(([_, stats]) => stats.total >= 3)
                    .sort((a, b) => parseFloat(a[1].winRate) - parseFloat(b[1].winRate));
                
                if (worstPairings.length > 0) {
                    const worstPair = worstPairings[0];
                    insights.push(`Anti-chemistry alert: <span class='stat-highlight'>${worstPair[0]}</span> only ${worstPair[1].winRate}% win rate together`);
                }
                
                // Find toughest SOS
                const sosArray = Object.entries(sos)
                    .filter(([player, data]) => data.count >= 3)
                    .sort((a, b) => a[1].avgOpponentHcp - b[1].avgOpponentHcp);
                
                if (sosArray.length > 0) {
                    const toughest = sosArray[0];
                    insights.push(`Toughest schedule: <span class='stat-highlight'>${toughest[0]}</span> faces ${toughest[1].avgOpponentHcp.toFixed(1)} avg handicap opponents`);
                }
                
                // Find easiest SOS
                if (sosArray.length > 0) {
                    const easiest = sosArray[sosArray.length - 1];
                    insights.push(`Easiest schedule: <span class='stat-highlight'>${easiest[0]}</span> faces ${easiest[1].avgOpponentHcp.toFixed(1)} avg handicap opponents`);
                }
                
                // Find most lopsided H2H
                const dominantH2H = Object.entries(h2hRecords)
                    .filter(([_, record]) => (record.player1Wins + record.player2Wins + record.ties) >= 2)
                    .map(([matchup, record]) => {
                        const total = record.player1Wins + record.player2Wins + record.ties;
                        const dominance = Math.max(record.player1Wins, record.player2Wins) / total;
                        const winner = record.player1Wins > record.player2Wins ? record.player1 : record.player2;
                        const loser = record.player1Wins > record.player2Wins ? record.player2 : record.player1;
                        const wins = Math.max(record.player1Wins, record.player2Wins);
                        const losses = Math.min(record.player1Wins, record.player2Wins);
                        return { matchup, winner, loser, wins, losses, ties: record.ties, dominance };
                    })
                    .sort((a, b) => b.dominance - a.dominance);
                
                if (dominantH2H.length > 0) {
                    const dominant = dominantH2H[0];
                    insights.push(`Most dominant H2H: <span class='stat-highlight'>${dominant.winner}</span> owns ${dominant.loser} (${dominant.wins}-${dominant.losses}-${dominant.ties})`);
                }
                
                // Perfect pairings
                const undefeatedPairs = pairingsArray.filter(([_, stats]) => stats.L === 0 && stats.total >= 2);
                if (undefeatedPairs.length > 0) {
                    const pair = undefeatedPairs[0];
                    insights.push(`Undefeated pairing: <span class='stat-highlight'>${pair[0]}</span> are ${pair[1].W}-${pair[1].L}-${pair[1].T} together`);
                }
                
                // Momentum insights
                if (momentum.fridayLeadHolds.kept + momentum.fridayLeadHolds.lost > 0) {
                    const fridayHoldRate = (momentum.fridayLeadHolds.kept / (momentum.fridayLeadHolds.kept + momentum.fridayLeadHolds.lost) * 100).toFixed(0);
                    insights.push(`Friday leaders win <span class='stat-highlight'>${fridayHoldRate}%</span> of the time (${momentum.fridayLeadHolds.kept}/${momentum.fridayLeadHolds.kept + momentum.fridayLeadHolds.lost})`);
                }
                
                if (momentum.comebacks.length > 0) {
                    const biggestComeback = momentum.comebacks[0];
                    insights.push(`Biggest comeback: <span class='stat-highlight'>${biggestComeback.team}</span> overcame ${biggestComeback.overcame} points on ${biggestComeback.day} (${biggestComeback.year})`);
                }
                
                // Upset insights
                const singlesUpsets = upsetAnalysis.byFormat.singles;
                const totalSingles = Object.values(singlesUpsets).reduce((sum, bucket) => sum + bucket.total, 0);
                const totalUpsets = Object.values(singlesUpsets).reduce((sum, bucket) => sum + bucket.upsets, 0);
                if (totalSingles > 10) {
                    const upsetRate = (totalUpsets / totalSingles * 100).toFixed(1);
                    insights.push(`Singles upset rate: <span class='stat-highlight'>${upsetRate}%</span> (higher handicap wins ${totalUpsets}/${totalSingles} matches)`);
                }
                
                // Biggest upset
                if (upsetAnalysis.biggestUpsets.length > 0) {
                    const biggest = upsetAnalysis.biggestUpsets[0];
                    insights.push(`Biggest upset: <span class='stat-highlight'>${biggest.winner}</span> (+${biggest.strokesGiven}) defeated ${biggest.loser} in ${biggest.year}`);
                }
                
                // Clutch players
                const playerNames = Object.keys(sos).filter(p => !captainNicknames.includes(p.toLowerCase()));
                const clutchRatings = playerNames.map(player => {
                    const rating = calculateClutchRating(player);
                    return { player, rating: parseFloat(rating.clutchRating), closeRecord: rating.closeMatchRecord };
                }).filter(p => p.rating > 0 && p.closeRecord !== "0-0-0");
                
                if (clutchRatings.length > 0) {
                    clutchRatings.sort((a, b) => b.rating - a.rating);
                    const mostClutch = clutchRatings[0];
                    insights.push(`Most clutch: <span class='stat-highlight'>${mostClutch.player}</span> with ${mostClutch.rating}% clutch rating (${mostClutch.closeRecord} in close matches)`);
                }
                
                // Format-specific upset rates
                const scrambleUpsets = upsetAnalysis.byFormat.scramble;
                if (Object.keys(scrambleUpsets).length > 0) {
                    const bucket10Plus = scrambleUpsets[10] || scrambleUpsets[15] || scrambleUpsets[20];
                    if (bucket10Plus && bucket10Plus.total >= 5) {
                        insights.push(`Teams giving 10+ strokes in scrambles win <span class='stat-highlight'>${bucket10Plus.favoriteRate}%</span> of the time`);
                    }
                }
                
                // Course performance insights
                Object.entries(coursePerformance).forEach(([course, data]) => {
                    if (course !== 'Unknown') {
                        // Find course horses
                        const courseHorses = Object.entries(data.players)
                            .filter(([_, stats]) => stats.total >= 3 && parseFloat(stats.winRate) >= 70)
                            .sort((a, b) => parseFloat(b[1].winRate) - parseFloat(a[1].winRate));
                        
                        if (courseHorses.length > 0) {
                            const horse = courseHorses[0];
                            insights.push(`Course horse at ${course}: <span class='stat-highlight'>${horse[0]}</span> wins ${horse[1].winRate}% (${horse[1].W}-${horse[1].L}-${horse[1].T})`);
                        }
                    }
                });
                
                // Revenge rate insights
                const revengeSpecialists = Object.entries(revengeData)
                    .filter(([_, data]) => data.opportunities >= 3)
                    .sort((a, b) => parseFloat(b[1].revengeRate) - parseFloat(a[1].revengeRate));
                
                if (revengeSpecialists.length > 0) {
                    const bestRevenger = revengeSpecialists[0];
                    insights.push(`Best at revenge: <span class='stat-highlight'>${bestRevenger[0]}</span> avenges losses ${bestRevenger[1].revengeRate}% of the time (${bestRevenger[1].revenges}/${bestRevenger[1].opportunities})`);
                }
                
                // Worst at revenge
                const worstRevengers = revengeSpecialists.filter(([_, data]) => parseFloat(data.revengeRate) < 30);
                if (worstRevengers.length > 0) {
                    const worst = worstRevengers[worstRevengers.length - 1];
                    insights.push(`Struggles with revenge: <span class='stat-highlight'>${worst[0]}</span> only ${worst[1].revengeRate}% revenge rate (${worst[1].revenges}/${worst[1].opportunities})`);
                }
                
                // Add some fallback insights if we don't have enough data
                if (insights.length === 0) {
                    insights.push("Still calculating statistics from match data...");
                }
                
                // Return a random insight from the calculated ones
                return insights[Math.floor(Math.random() * insights.length)];
                
            } catch (error) {
                console.error('Error generating stats:', error);
                return "Analyzing match data...";
            }
        }

        // Keep the old function name for compatibility but use the new one
        function generateInsightfulStats() {
            return generateMeaningfulStats();
        }

        function calculateFormatSpecialists() {
            const formatStats = {};
            
            playerList.forEach(player => {
                formatStats[player] = {
                    fourball: { wins: 0, total: 0, rate: 0 },
                    altShot: { wins: 0, total: 0, rate: 0 },
                    singles: { wins: 0, total: 0, rate: 0 }
                };
            });
            
            // Process all matches
            Object.values(matchData).forEach(yearData => {
                yearData.matches.forEach(match => {
                    // Process fourball
                    if (match.type === 'Fourball') {
                        match.players.pardo.forEach(player => {
                            if (formatStats[player]) {
                                formatStats[player].fourball.total++;
                                if (match.winner === 'pardo') {
                                    formatStats[player].fourball.wins++;
                                }
                            }
                        });
                        match.players.salas.forEach(player => {
                            if (formatStats[player]) {
                                formatStats[player].fourball.total++;
                                if (match.winner === 'salas') {
                                    formatStats[player].fourball.wins++;
                                }
                            }
                        });
                    }
                    // Process alt shot
                    else if (match.type === 'Alt Shot') {
                        match.players.pardo.forEach(player => {
                            if (formatStats[player]) {
                                formatStats[player].altShot.total++;
                                if (match.winner === 'pardo') {
                                    formatStats[player].altShot.wins++;
                                }
                            }
                        });
                        match.players.salas.forEach(player => {
                            if (formatStats[player]) {
                                formatStats[player].altShot.total++;
                                if (match.winner === 'salas') {
                                    formatStats[player].altShot.wins++;
                                }
                            }
                        });
                    }
                    // Process singles
                    else if (match.type === 'Singles') {
                        match.players.pardo.forEach(player => {
                            if (formatStats[player]) {
                                formatStats[player].singles.total++;
                                if (match.winner === 'pardo') {
                                    formatStats[player].singles.wins++;
                                }
                            }
                        });
                        match.players.salas.forEach(player => {
                            if (formatStats[player]) {
                                formatStats[player].singles.total++;
                                if (match.winner === 'salas') {
                                    formatStats[player].singles.wins++;
                                }
                            }
                        });
                    }
                });
            });
            
            // Calculate win rates
            Object.values(formatStats).forEach(stats => {
                if (stats.fourball.total > 0) {
                    stats.fourball.rate = stats.fourball.wins / stats.fourball.total;
                }
                if (stats.altShot.total > 0) {
                    stats.altShot.rate = stats.altShot.wins / stats.altShot.total;
                }
                if (stats.singles.total > 0) {
                    stats.singles.rate = stats.singles.wins / stats.singles.total;
                }
            });
            
            return formatStats;
        }


        function show2025Dashboard(container) {
            // Check if match data is loaded
            if (!matchData || !matchData[2025]) {
                container.innerHTML = '<h2>2025 Dashboard</h2><p>Loading data...</p>';
                return;
            }
            
            const yearData = matchData[2025];
            container.innerHTML = `
                <h2 style="margin-bottom: 2rem;">2025 Company Retreat - ${yearData.captains ? Object.values(yearData.captains).join(' vs ') : 'Team Competition'}</h2>
                
                <div class="metric-card">
                    <div class="metric-title">📊 Key Storylines from CR8</div>
                    <div class="metric-item">
                        <span>Largest margin of victory</span>
                        <span class="stat-highlight">15.5 - 8.5 (tied with 2021)</span>
                    </div>
                    <div class="metric-item">
                        <span>Saturday/Sunday dominance</span>
                        <span class="stat-highlight">9.5 - 2.5 run</span>
                    </div>
                    <div class="metric-item">
                        <span>Singles day differential</span>
                        <span class="stat-highlight">4.5 - 2.5 (largest ever)</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">MVP Performance</div>
                        <div class="stat-value" style="font-size: 1.5rem;">Danny Yanez</div>
                        <div style="color: var(--text-muted);">3-0-0 (Scramble W, Best Ball W, Singles W)</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">Clutch Captain</div>
                        <div class="stat-value" style="font-size: 1.5rem;">Lawrence Pardo</div>
                        <div style="color: var(--text-muted);">2-1-0 with key Singles victory</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">Portal Brothers</div>
                        <div class="stat-value" style="font-size: 1.5rem;">4-0-1</div>
                        <div style="color: var(--text-muted);">Undefeated when paired</div>
                    </div>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Format Breakdown</h3>
                <div class="metric-card">
                    <div class="metric-item">
                        <span><strong>Friday Scrambles</strong></span>
                        <span>Team Pardo 5 - 1 Team Salas</span>
                    </div>
                    <div class="metric-item">
                        <span><strong>Saturday Best Ball</strong></span>
                        <span>Team Pardo 4.5 - 1.5 Team Salas</span>
                    </div>
                    <div class="metric-item">
                        <span><strong>Sunday Singles</strong></span>
                        <span>Team Pardo 4.5 - 2.5 Team Salas</span>
                    </div>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Statistical Anomalies</h3>
                <div class="metric-card">
                    <div style="padding: 1rem; line-height: 1.8;">
                        <p>• <strong>Jordan Portal (+3.1)</strong> became the first player to compete while giving strokes to every opponent</p>
                        <p>• <strong>Perfect Friday:</strong> Team Pardo nearly swept Scrambles 6-0 (lost only 1 match by 2&1)</p>
                        <p>• <strong>Pardo Pattern:</strong> Lawrence Pardo improved to 2-0 in Scrambles with different partners each year</p>
                        <p>• <strong>Second Year Success:</strong> Joey Pinto (1-2) earned his first CR victory after going winless in 2024</p>
                    </div>
                </div>
            `;
        }

        // Name mapping to handle abbreviated names in match data
        function getFullPlayerName(shortName, allPlayers) {
            // Direct match
            if (allPlayers.has(shortName)) return shortName;
            
            // Common mappings
            const nameMap = {
                'Cabrera': 'Pete Cabrera',
                'Alfonso': 'Carlos Alfonso',
                'B. Lastra': 'Boogie Lastra',
                'A. Lastra': 'Alex Lastra',
                'Martinez': 'Mario Martinez',
                'S. Diaz': 'Stefano Diaz',
                'E. Diaz': 'Eric Diaz',
                'J. Portal': 'Javi Portal',
                'Jo. Portal': 'Jordan Portal',
                'Yanez': 'Danny Yanez',
                'Noy': 'Jo Noy',
                'S. Noy': 'Shawn Noy',
                'Pardo': 'Lawrence Pardo',
                'Salas': 'Javi Salas',
                'Quintana': 'Michael Quintana',
                'Enjamio': 'Carlos Enjamio',
                'Riobueno': 'Victor Riobueno',
                'Vargas': 'Javi Vargas',
                'Del Cristo': 'David Del Cristo',
                'Restrepo': 'Mauricio Restrepo',
                'Guasch': 'Andrew Guasch',
                'De Armas': 'Roger De Armas',
                'Ramirez': 'Skippy Ramirez',
                'Pinto': 'Joey Pinto'
            };
            
            if (nameMap[shortName]) return nameMap[shortName];
            
            // Try to find by last name
            for (const fullName of allPlayers) {
                const parts = fullName.split(' ');
                const lastName = parts[parts.length - 1];
                if (lastName === shortName) return fullName;
            }
            
            return shortName; // Return original if no match found
        }
        
        // Universal function to extract player stats from matchData
        function getPlayerStatsFromMatchData(playerName) {
            const stats = {
                scrambleRecord: { W: 0, L: 0, T: 0 },
                bestBallRecord: { W: 0, L: 0, T: 0 },
                singlesRecord: { W: 0, L: 0, T: 0 },
                totalRecord: { W: 0, L: 0, T: 0 },
                yearsPlayed: [],
                opponents: [],
                matchDetails: []
            };
            
            // Helper function to check if a name matches
            const isPlayerInMatch = (matchName, targetName) => {
                if (matchName === targetName) return true;
                
                // Check if it's a last name match
                const targetParts = targetName.split(' ');
                const targetLastName = targetParts[targetParts.length - 1];
                if (matchName === targetLastName) return true;
                
                // Check specific mappings
                const mappings = {
                    'J. Portal': 'Javi Portal',
                    'Jo. Portal': 'Jordan Portal',
                    'B. Lastra': 'Boogie Lastra',
                    'A. Lastra': 'Alex Lastra',
                    'S. Diaz': 'Stefano Diaz',
                    'E. Diaz': 'Eric Diaz',
                    'S. Noy': 'Shawn Noy'
                };
                
                return mappings[matchName] === targetName;
            };
            
            Object.entries(matchData).forEach(([year, yearData]) => {
                let playedThisYear = false;
                
                // Parse scrambles
                yearData.scrambleResults?.forEach(match => {
                    const captainKeys = Object.keys(yearData.captains || {});
                    // Check if player is on first captain's team (result is from their perspective)
                    const firstCaptain = captainKeys[0];
                    const secondCaptain = captainKeys[1];
                    
                    if (match[firstCaptain] && Array.isArray(match[firstCaptain]) && match[firstCaptain].some(name => isPlayerInMatch(name, playerName))) {
                        playedThisYear = true;
                        // Player is on first team, result is correct as-is
                        if (match.result === 'W') stats.scrambleRecord.W++;
                        else if (match.result === 'L') stats.scrambleRecord.L++;
                        else if (match.result === 'T') stats.scrambleRecord.T++;
                        
                        if (match[secondCaptain]) {
                            stats.opponents.push(...match[secondCaptain]);
                        }
                    } else if (match[secondCaptain] && Array.isArray(match[secondCaptain]) && match[secondCaptain].some(name => isPlayerInMatch(name, playerName))) {
                        playedThisYear = true;
                        // Player is on second team, need to flip result
                        if (match.result === 'W') stats.scrambleRecord.L++; // They lost
                        else if (match.result === 'L') stats.scrambleRecord.W++; // They won
                        else if (match.result === 'T') stats.scrambleRecord.T++;
                        
                        if (match[firstCaptain]) {
                            stats.opponents.push(...match[firstCaptain]);
                        }
                    }
                });
                
                // Parse best ball
                yearData.bestBallResults?.forEach(match => {
                    const captainKeys = Object.keys(yearData.captains || {});
                    const firstCaptain = captainKeys[0];
                    const secondCaptain = captainKeys[1];
                    
                    if (match[firstCaptain] && Array.isArray(match[firstCaptain]) && match[firstCaptain].some(name => isPlayerInMatch(name, playerName))) {
                        // Player is on first team, result is correct as-is
                        if (match.result === 'W') stats.bestBallRecord.W++;
                        else if (match.result === 'L') stats.bestBallRecord.L++;
                        else if (match.result === 'T') stats.bestBallRecord.T++;
                    } else if (match[secondCaptain] && Array.isArray(match[secondCaptain]) && match[secondCaptain].some(name => isPlayerInMatch(name, playerName))) {
                        // Player is on second team, need to flip result
                        if (match.result === 'W') stats.bestBallRecord.L++; // They lost
                        else if (match.result === 'L') stats.bestBallRecord.W++; // They won
                        else if (match.result === 'T') stats.bestBallRecord.T++;
                    }
                });
                
                // Parse singles
                yearData.singlesResults?.forEach(match => {
                    const captainKeys = Object.keys(yearData.captains || {});
                    const firstCaptain = captainKeys[0];
                    const secondCaptain = captainKeys[1];
                    
                    if (isPlayerInMatch(match[firstCaptain], playerName)) {
                        // Player is on first team, result is correct as-is
                        if (match.result === 'W') stats.singlesRecord.W++;
                        else if (match.result === 'L') stats.singlesRecord.L++;
                        else if (match.result === 'T') stats.singlesRecord.T++;
                        
                        stats.matchDetails.push({
                            year: year,
                            format: 'singles',
                            opponent: match[secondCaptain],
                            result: match.result,
                            score: match.score
                        });
                    } else if (isPlayerInMatch(match[secondCaptain], playerName)) {
                        // Player is on second team, need to flip result
                        if (match.result === 'W') stats.singlesRecord.L++; // They lost
                        else if (match.result === 'L') stats.singlesRecord.W++; // They won
                        else if (match.result === 'T') stats.singlesRecord.T++;
                        
                        stats.matchDetails.push({
                            year: year,
                            format: 'singles',
                            opponent: match[firstCaptain],
                            result: match.result === 'W' ? 'L' : match.result === 'L' ? 'W' : 'T',
                            score: match.score
                        });
                    }
                });
                
                if (playedThisYear) {
                    stats.yearsPlayed.push(year);
                }
            });
            
            // Calculate totals
            stats.totalRecord.W = stats.scrambleRecord.W + stats.bestBallRecord.W + stats.singlesRecord.W;
            stats.totalRecord.L = stats.scrambleRecord.L + stats.bestBallRecord.L + stats.singlesRecord.L;
            stats.totalRecord.T = stats.scrambleRecord.T + stats.bestBallRecord.T + stats.singlesRecord.T;
            
            return stats;
        }

        function showHistory(container) {
            let selectedYear = 2025;
            
            const renderMatchHistory = (year) => {
                const yearData = matchData[year];
                const yearCourseData = courseData[year];
                
                if (!yearData) {
                    container.innerHTML = '<p>No data available for this year</p>';
                    return;
                }
                
                let html = `
                    <h2 style="margin-bottom: 1rem;">History</h2>
                    
                    <div class="filter-buttons" style="margin-bottom: 2rem;">
                        ${Object.keys(matchData).sort((a, b) => b - a).map(y => `
                            <button class="filter-btn ${y == year ? 'active' : ''}" onclick="selectMatchYear(${y})">${y}</button>
                        `).join('')}
                    </div>
                    
                    <div class="year-card">
                        <div class="year-header">
                            <div>
                                <div class="year-title">${year} - ${yearData.captains ? Object.values(yearData.captains).join(' vs ') : 'Company Retreat'}</div>
                                <div class="captain-info">${yearData.date || ''}</div>
                            </div>
                            <div class="score ${yearData.finalScore ? 'winner' : ''}">${yearData.finalScore || ''}</div>
                        </div>
                        ${yearCourseData ? `
                            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                                <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Course Information:</h4>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                                    <div>
                                        <strong>Friday (Scrambles):</strong><br>
                                        ${yearCourseData.scramble.course}<br>
                                        <span style="color: var(--text-muted);">Rating: ${yearCourseData.scramble.rating} / Slope: ${yearCourseData.scramble.slope}</span>
                                    </div>
                                    <div>
                                        <strong>Saturday (Best Ball):</strong><br>
                                        ${yearCourseData.bestBall.course}<br>
                                        <span style="color: var(--text-muted);">Rating: ${yearCourseData.bestBall.rating} / Slope: ${yearCourseData.bestBall.slope}</span>
                                    </div>
                                    <div>
                                        <strong>Sunday (Singles):</strong><br>
                                        ${yearCourseData.singles.course}<br>
                                        <span style="color: var(--text-muted);">Rating: ${yearCourseData.singles.rating} / Slope: ${yearCourseData.singles.slope}</span>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
                
                if (yearData.scrambleResults) {
                    const showScoreColumn = year >= 2022;
                    html += `
                        <h3 style="margin: 2rem 0 1rem;">Friday - Scrambles at ${yearData.courses.scramble.name}</h3>
                        <div class="metric-card">
                            <table style="width: 100%;">
                                <thead>
                                    <tr>
                                        <th>Match</th>
                                        <th>Team ${Object.keys(yearData.captains)[0]}</th>
                                        <th>Team ${Object.keys(yearData.captains)[1]}</th>
                                        <th>Result</th>
                                        ${showScoreColumn ? '<th>Score</th>' : ''}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${yearData.scrambleResults.map((match, idx) => {
                                        const captainKeys = Object.keys(yearData.captains || {});
                                        const team1 = captainKeys[0];
                                        const team2 = captainKeys[1];
                                        return `
                                        <tr>
                                            <td>${idx + 1}</td>
                                            <td>${match[team1] ? match[team1].join(' & ') : ''}</td>
                                            <td>${match[team2] ? match[team2].join(' & ') : ''}</td>
                                            <td class="${match.result === 'W' ? 'winner' : match.result === 'L' ? 'loser' : ''}">${match.result || ''}</td>
                                            ${showScoreColumn ? `<td>${match.score || ''}</td>` : ''}
                                        </tr>
                                    `}).join('')}
                                </tbody>
                            </table>
                            <div style="text-align: right; margin-top: 1rem; font-weight: 600;">
                                Day Total: ${yearData.dailyScores?.friday?.[Object.keys(yearData.captains || {})[0]] || 0} - ${yearData.dailyScores?.friday?.[Object.keys(yearData.captains || {})[1]] || 0}
                            </div>
                        </div>
                    `;
                }
                
                if (yearData.bestBallResults) {
                    const showScoreColumn = year >= 2022;
                    html += `
                        <h3 style="margin: 2rem 0 1rem;">Saturday - Best Ball at ${yearData.courses.bestBall.name}</h3>
                        <div class="metric-card">
                            <table style="width: 100%;">
                                <thead>
                                    <tr>
                                        <th>Match</th>
                                        <th>Team ${Object.keys(yearData.captains)[0]}</th>
                                        <th>Team ${Object.keys(yearData.captains)[1]}</th>
                                        <th>Result</th>
                                        ${showScoreColumn ? '<th>Score</th>' : ''}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${yearData.bestBallResults.map((match, idx) => {
                                        const captainKeys = Object.keys(yearData.captains || {});
                                        const team1 = captainKeys[0];
                                        const team2 = captainKeys[1];
                                        return `
                                        <tr>
                                            <td>${idx + 1}</td>
                                            <td>${match[team1] ? match[team1].join(' & ') : ''}</td>
                                            <td>${match[team2] ? match[team2].join(' & ') : ''}</td>
                                            <td class="${match.result === 'W' ? 'winner' : match.result === 'L' ? 'loser' : ''}">${match.result || ''}</td>
                                            ${showScoreColumn ? `<td>${match.score || ''}</td>` : ''}
                                        </tr>
                                    `}).join('')}
                                </tbody>
                            </table>
                            <div style="text-align: right; margin-top: 1rem; font-weight: 600;">
                                Day Total: ${yearData.dailyScores?.saturday?.[Object.keys(yearData.captains || {})[0]] || 0} - ${yearData.dailyScores?.saturday?.[Object.keys(yearData.captains || {})[1]] || 0}
                            </div>
                        </div>
                    `;
                }
                
                if (yearData.singlesResults) {
                    const showScoreColumn = year >= 2022;
                    html += `
                        <h3 style="margin: 2rem 0 1rem;">Sunday - Singles at ${yearData.courses.singles.name}</h3>
                        <div class="metric-card">
                            <table style="width: 100%;">
                                <thead>
                                    <tr>
                                        <th>Match</th>
                                        <th>Team ${Object.keys(yearData.captains)[0]}</th>
                                        <th>Team ${Object.keys(yearData.captains)[1]}</th>
                                        <th>Result</th>
                                        ${showScoreColumn ? '<th>Score</th>' : ''}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${yearData.singlesResults.map((match, idx) => {
                                        const captainKeys = Object.keys(yearData.captains || {});
                                        const team1 = captainKeys[0];
                                        const team2 = captainKeys[1];
                                        return `
                                        <tr>
                                            <td>${idx + 1}</td>
                                            <td>${match[team1] || ''}</td>
                                            <td>${match[team2] || ''}</td>
                                            <td class="${match.result === 'W' ? 'winner' : match.result === 'L' ? 'loser' : ''}">${match.result || ''}</td>
                                            ${showScoreColumn ? `<td>${match.score || ''}</td>` : ''}
                                        </tr>
                                    `}).join('')}
                                </tbody>
                            </table>
                            <div style="text-align: right; margin-top: 1rem; font-weight: 600;">
                                Day Total: ${yearData.dailyScores?.sunday?.[Object.keys(yearData.captains || {})[0]] || 0} - ${yearData.dailyScores?.sunday?.[Object.keys(yearData.captains || {})[1]] || 0}
                            </div>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            };
            
            window.selectMatchYear = (year) => {
                selectedYear = year;
                renderMatchHistory(year);
            };
            
            renderMatchHistory(selectedYear);
        }

        function showPlayerAnalytics(container) {
            // Check if match data is loaded
            if (!matchData || Object.keys(matchData).length === 0) {
                container.innerHTML = '<h2>Player Analytics</h2><p>Loading data...</p>';
                return;
            }
            
            // Get all unique players from matchData
            const allPlayers = new Set();
            Object.values(matchData).forEach(yearData => {
                // Add from team rosters
                if (yearData.teamPardo) yearData.teamPardo.forEach(p => allPlayers.add(p));
                if (yearData.teamSalas) yearData.teamSalas.forEach(p => allPlayers.add(p));
                if (yearData.teamVictor) yearData.teamVictor.forEach(p => allPlayers.add(p));
                if (yearData.teamCarlos) yearData.teamCarlos.forEach(p => allPlayers.add(p));
                
                // Add from match results
                ['scrambleResults', 'bestBallResults', 'singlesResults'].forEach(format => {
                    yearData[format]?.forEach(match => {
                        Object.values(match).forEach(value => {
                            if (Array.isArray(value)) {
                                value.forEach(name => {
                                    if (typeof name === 'string' && name.length > 1) allPlayers.add(name);
                                });
                            } else if (typeof value === 'string' && value.length > 1 && !['W', 'L', 'T'].includes(value) && !value.includes('&')) {
                                allPlayers.add(value);
                            }
                        });
                    });
                });
            });
            
            const playerList = Array.from(allPlayers).sort();
            let selectedPlayer = playerList[0] || "Danny Yanez";
            
            const renderPlayerAnalytics = (playerName) => {
                const stats = getPlayerStatsFromMatchData(playerName);
                
                const totalMatches = stats.totalRecord.W + stats.totalRecord.L + stats.totalRecord.T;
                const winRate = totalMatches > 0 ? (stats.totalRecord.W / totalMatches * 100).toFixed(1) : 0;
                
                let html = `
                    <h2 style="margin-bottom: 1rem;">Player Analytics</h2>
                    
                    <div style="margin-bottom: 2rem;">
                        <select onchange="selectPlayer(this.value)" style="padding: 0.5rem; font-size: 1rem; border-radius: 0.5rem;">
                            ${playerList.map(p => `
                                <option value="${p}" ${p === playerName ? 'selected' : ''}>${p}</option>
                            `).join('')}
                        </select>
                    </div>
                    
                    <div class="player-card" style="margin-bottom: 2rem;">
                        <h3 class="player-name">${playerName}</h3>
                        <div class="record">
                            <span class="wins">W: ${stats.totalRecord.W}</span>
                            <span class="losses">L: ${stats.totalRecord.L}</span>
                            <span class="ties">T: ${stats.totalRecord.T}</span>
                        </div>
                        <div style="margin-top: 1rem;">
                            <strong>Win Rate:</strong> ${winRate}%<br>
                            <strong>CRs Played:</strong> ${stats.yearsPlayed.length}<br>
                            <strong>Years:</strong> ${stats.yearsPlayed.join(', ')}<br>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-title">📊 Format Breakdown</div>
                        <div class="metric-item">
                            <span><strong>Scrambles</strong></span>
                            <span>${stats.scrambleRecord.W}-${stats.scrambleRecord.L}-${stats.scrambleRecord.T}</span>
                        </div>
                        <div class="metric-item">
                            <span><strong>Best Ball</strong></span>
                            <span>${stats.bestBallRecord.W}-${stats.bestBallRecord.L}-${stats.bestBallRecord.T}</span>
                        </div>
                        <div class="metric-item">
                            <span><strong>Singles</strong></span>
                            <span>${stats.singlesRecord.W}-${stats.singlesRecord.L}-${stats.singlesRecord.T}</span>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-title">🏆 Notable Achievements</div>
                        <div style="padding: 1rem; line-height: 1.8;">
                            ${stats.yearsPlayed.length === 8 ? '• Played in all 8 Company Retreats<br>' : ''}
                            ${stats.totalRecord.W === 0 ? '• Seeking first victory<br>' : ''}
                            ${stats.totalRecord.W > 15 ? '• Elite winner with ' + stats.totalRecord.W + ' career victories<br>' : ''}
                            ${winRate > 70 ? '• Outstanding ' + winRate + '% career win rate<br>' : ''}
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
            };
            
            window.selectPlayer = (playerName) => {
                selectedPlayer = playerName;
                renderPlayerAnalytics(playerName);
            };
            
            renderPlayerAnalytics(selectedPlayer);
        }

        function showAdvancedAnalytics(container) {
            // Check if match data is loaded
            if (!matchData || Object.keys(matchData).length === 0) {
                container.innerHTML = '<h2>Advanced Analytics</h2><p>Loading data...</p>';
                return;
            }
            
            // Calculate real analytics from matchData
            const calculateCloseMatchStats = () => {
                const closeMatchStats = {};
                
                Object.entries(matchData).forEach(([year, yearData]) => {
                    ['scrambleResults', 'bestBallResults', 'singlesResults'].forEach(format => {
                        yearData[format]?.forEach(match => {
                            if (match.score && (match.score.includes('2&1') || match.score.includes('1up'))) {
                                // This is a close match
                                Object.keys(yearData.captains || {}).forEach(captain => {
                                    const players = match[captain];
                                    if (players) {
                                        const playerNames = Array.isArray(players) ? players : [players];
                                        playerNames.forEach(player => {
                                            if (!closeMatchStats[player]) {
                                                closeMatchStats[player] = { W: 0, L: 0, T: 0 };
                                            }
                                            if (match.result === 'W') closeMatchStats[player].W++;
                                            else if (match.result === 'L') closeMatchStats[player].L++;
                                            else if (match.result === 'T') closeMatchStats[player].T++;
                                        });
                                    }
                                });
                            }
                        });
                    });
                });
                
                return closeMatchStats;
            };
            
            const closeMatchStats = calculateCloseMatchStats();
            
            // Calculate match counts by year
            const matchCountsByYear = {};
            Object.entries(matchData).forEach(([year, yearData]) => {
                let totalMatches = 0;
                if (yearData.scrambleResults) totalMatches += yearData.scrambleResults.length;
                if (yearData.bestBallResults) totalMatches += yearData.bestBallResults.length;
                if (yearData.singlesResults) totalMatches += yearData.singlesResults.length;
                matchCountsByYear[year] = totalMatches;
            });
            
            // Get top clutch performers
            const clutchPerformers = Object.entries(closeMatchStats)
                .filter(([name, stats]) => (stats.W + stats.L + stats.T) >= 2)
                .map(([name, stats]) => {
                    const total = stats.W + stats.L + stats.T;
                    const winRate = total > 0 ? (stats.W / total * 100).toFixed(1) : 0;
                    return { name, stats, total, winRate };
                })
                .sort((a, b) => b.winRate - a.winRate)
                .slice(0, 5);
            
            container.innerHTML = `
                <h2 style="margin-bottom: 2rem;">Advanced Analytics</h2>
                
                <div class="metric-card">
                    <div class="metric-title">📊 Match Statistics by Year</div>
                    ${Object.entries(matchCountsByYear).map(([year, count]) => `
                        <div class="metric-item">
                            <span>${year}</span>
                            <span>${count} total matches</span>
                        </div>
                    `).join('')}
                </div>
                
                ${clutchPerformers.length > 0 ? `
                <div class="metric-card">
                    <div class="metric-title">🎯 Clutch Performance Rating</div>
                    <p style="color: var(--text-muted); margin-bottom: 1rem;">
                        Win rate in matches decided by 2&1 or less:
                    </p>
                    ${clutchPerformers.map(p => `
                        <div class="metric-item">
                            <span>${p.name}</span>
                            <span>${p.winRate}% (${p.stats.W}-${p.stats.L}${p.stats.T > 0 ? '-' + p.stats.T : ''}) in close matches</span>
                        </div>
                    `).join('')}
                </div>
                ` : ''}

                
                <div class="metric-card">
                    <div class="metric-title">📈 Year-by-Year Champions</div>
                    ${Object.entries(matchData)
                        .filter(([year, data]) => data.finalScore)
                        .sort(([a], [b]) => b - a)
                        .map(([year, data]) => {
                            const winningCaptain = Object.entries(data.captains || {}).find(([key, name]) => 
                                data.finalScore && parseFloat(data.finalScore.split('-')[0]) > parseFloat(data.finalScore.split('-')[1])
                            );
                            return `
                            <div class="metric-item">
                                <span>${year} - ${winningCaptain ? winningCaptain[1] : 'Unknown'}</span>
                                <span>${data.finalScore}</span>
                            </div>
                        `}).join('')}
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">🏆 Most Matches Played</div>
                    ${(() => {
                        const matchCounts = {};
                        Object.values(matchData).forEach(yearData => {
                            ['scrambleResults', 'bestBallResults', 'singlesResults'].forEach(format => {
                                yearData[format]?.forEach(match => {
                                    Object.values(match).forEach(value => {
                                        if (Array.isArray(value)) {
                                            value.forEach(name => {
                                                if (typeof name === 'string' && name.length > 1) {
                                                    matchCounts[name] = (matchCounts[name] || 0) + 1;
                                                }
                                            });
                                        } else if (typeof value === 'string' && value.length > 1 && !['W', 'L', 'T'].includes(value) && !value.includes('&')) {
                                            matchCounts[value] = (matchCounts[value] || 0) + 1;
                                        }
                                    });
                                });
                            });
                        });
                        
                        return Object.entries(matchCounts)
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 5)
                            .map(([name, count]) => `
                                <div class="metric-item">
                                    <span>${name}</span>
                                    <span>${count} matches</span>
                                </div>
                            `).join('');
                    })()}
                </div>
                    </div>
                </div>
            `;
        }


        function showTrends(container) {
            console.log('Trends - matchData:', matchData);
            console.log('Trends - handicapData:', handicapData);
            
            // Check if match data is loaded
            if (!matchData || Object.keys(matchData).length === 0) {
                container.innerHTML = '<h2>Trends & Patterns</h2><p>Loading data...</p>';
                return;
            }
            
            // Victory margin trends from actual matchData
            const marginsByYear = Object.entries(matchData).map(([year, data]) => {
                // Parse score like "15.5-8.5" to calculate margin
                const score = data.finalScore || '';
                const parts = score.split('-').map(s => parseFloat(s));
                const margin = parts.length === 2 ? Math.abs(parts[0] - parts[1]) : 0;
                return {
                    year: parseInt(year),
                    margin: margin,
                    score: score
                };
            }).filter(m => m.margin > 0).sort((a, b) => a.year - b.year);
            
            const avgMarginEarly = marginsByYear.slice(0, 3).reduce((sum, m) => sum + m.margin, 0) / 3;
            const avgMarginRecent = marginsByYear.slice(-3).reduce((sum, m) => sum + m.margin, 0) / 3;
            
            // Get all players from matchData
            const allPlayers = new Set();
            Object.values(matchData).forEach(yearData => {
                ['scrambleResults', 'bestBallResults', 'singlesResults'].forEach(format => {
                    yearData[format]?.forEach(match => {
                        Object.values(match).forEach(value => {
                            if (Array.isArray(value)) {
                                value.forEach(name => {
                                    if (typeof name === 'string' && name.length > 1) allPlayers.add(name);
                                });
                            } else if (typeof value === 'string' && value.length > 1 && !['W', 'L', 'T'].includes(value) && !value.includes('&')) {
                                allPlayers.add(value);
                            }
                        });
                    });
                });
            });
            
            // Handicap improvement leaders
            const handicapImprovements = Array.from(allPlayers).map(player => {
                if (!handicapData[player]) return null;
                const years = Object.keys(handicapData[player]).sort();
                if (years.length < 2) return null;
                
                const firstYear = handicapData[player][years[0]];
                const lastYear = handicapData[player][years[years.length - 1]];
                const improvement = firstYear - lastYear;
                
                return {
                    player,
                    improvement,
                    firstYear: years[0],
                    lastYear: years[years.length - 1],
                    firstHcp: firstYear,
                    currentHcp: lastYear
                };
            }).filter(p => p && p.improvement > 0).sort((a, b) => b.improvement - a.improvement);
            
            // Format specialists from real data
            const formatSpecialists = {
                scramble: { name: '', wins: 0, total: 0, rate: 0 },
                bestBall: { name: '', wins: 0, total: 0, rate: 0 },
                singles: { name: '', wins: 0, total: 0, rate: 0 }
            };
            
            Array.from(allPlayers).forEach(player => {
                const stats = getPlayerStatsFromMatchData(player);
                
                // Check scramble
                const scrambleTotal = stats.scrambleRecord.W + stats.scrambleRecord.L + stats.scrambleRecord.T;
                if (scrambleTotal > 0) {
                    const scrambleRate = stats.scrambleRecord.W / scrambleTotal;
                    if (scrambleRate > formatSpecialists.scramble.rate) {
                        formatSpecialists.scramble = { name: player, wins: stats.scrambleRecord.W, total: scrambleTotal, rate: scrambleRate };
                    }
                }
                
                // Check best ball
                const bestBallTotal = stats.bestBallRecord.W + stats.bestBallRecord.L + stats.bestBallRecord.T;
                if (bestBallTotal > 0) {
                    const bestBallRate = stats.bestBallRecord.W / bestBallTotal;
                    if (bestBallRate > formatSpecialists.bestBall.rate) {
                        formatSpecialists.bestBall = { name: player, wins: stats.bestBallRecord.W, total: bestBallTotal, rate: bestBallRate };
                    }
                }
                
                // Check singles
                const singlesTotal = stats.singlesRecord.W + stats.singlesRecord.L + stats.singlesRecord.T;
                if (singlesTotal > 0) {
                    const singlesRate = stats.singlesRecord.W / singlesTotal;
                    if (singlesRate > formatSpecialists.singles.rate) {
                        formatSpecialists.singles = { name: player, wins: stats.singlesRecord.W, total: singlesTotal, rate: singlesRate };
                    }
                }
            });
            
            container.innerHTML = `
                <h2>Trends & Patterns</h2>
                
                <div class="metric-card">
                    <div class="metric-title">📊 Victory Margin Evolution</div>
                    <div class="metric-item">
                        <span>Early years average (2018-2020)</span>
                        <span class="stat-value">${avgMarginEarly.toFixed(1)} points</span>
                    </div>
                    <div class="metric-item">
                        <span>Recent years average (2023-2025)</span>
                        <span class="stat-value">${avgMarginRecent.toFixed(1)} points</span>
                    </div>
                    <div class="metric-item">
                        <span>Trend</span>
                        <span class="stat-value ${avgMarginRecent > avgMarginEarly ? 'text-danger' : 'text-success'}">
                            ${avgMarginRecent > avgMarginEarly ? '↑' : '↓'} 
                            ${Math.abs(avgMarginRecent - avgMarginEarly).toFixed(1)} point change
                        </span>
                    </div>
                    <div class="metric-note">
                        ${avgMarginRecent > avgMarginEarly ? 
                            'Matches becoming less competitive' : 
                            'Matches becoming more competitive'}
                    </div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">🎯 Greatest Handicap Improvements</div>
                    ${handicapImprovements.slice(0, 4).map(p => `
                        <div class="metric-item">
                            <span>${p.player}</span>
                            <span class="stat-value text-success">
                                ↓ ${p.improvement} strokes
                                <span class="metric-note">(${p.firstHcp} → ${p.currentHcp})</span>
                            </span>
                        </div>
                    `).join('')}
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">🎯 Format Specialists</div>
                    <div class="metric-note">Highest win rate by format (min 3 matches):</div>
                    ${formatSpecialists.scramble.total >= 3 ? `
                        <div class="metric-item">
                            <span>Scramble Champion</span>
                            <span class="stat-value">${formatSpecialists.scramble.name} (${(formatSpecialists.scramble.rate * 100).toFixed(0)}%)</span>
                        </div>
                    ` : ''}
                    ${formatSpecialists.bestBall.total >= 3 ? `
                        <div class="metric-item">
                            <span>Best Ball Expert</span>
                            <span class="stat-value">${formatSpecialists.bestBall.name} (${(formatSpecialists.bestBall.rate * 100).toFixed(0)}%)</span>
                        </div>
                    ` : ''}
                    ${formatSpecialists.singles.total >= 3 ? `
                        <div class="metric-item">
                            <span>Singles Specialist</span>
                            <span class="stat-value">${formatSpecialists.singles.name} (${(formatSpecialists.singles.rate * 100).toFixed(0)}%)</span>
                        </div>
                    ` : ''}
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">📈 Victory Margins by Year</div>
                    ${marginsByYear.map(m => `
                        <div class="metric-item">
                            <span>${m.year}</span>
                            <span class="stat-value">${m.score} (${m.margin} point margin)</span>
                        </div>
                    `).join('')}
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">📊 Match Count by Format</div>
                    ${(() => {
                        let scrambleCount = 0, bestBallCount = 0, singlesCount = 0;
                        Object.values(matchData).forEach(yearData => {
                            if (yearData.scrambleResults) scrambleCount += yearData.scrambleResults.length;
                            if (yearData.bestBallResults) bestBallCount += yearData.bestBallResults.length;
                            if (yearData.singlesResults) singlesCount += yearData.singlesResults.length;
                        });
                        return `
                            <div class="metric-item">
                                <span>Total Scramble Matches</span>
                                <span class="stat-value">${scrambleCount}</span>
                            </div>
                            <div class="metric-item">
                                <span>Total Best Ball Matches</span>
                                <span class="stat-value">${bestBallCount}</span>
                            </div>
                            <div class="metric-item">
                                <span>Total Singles Matches</span>
                                <span class="stat-value">${singlesCount}</span>
                            </div>
                        `;
                    })()}
                </div>
            `;
        }

        function showOverview(container) {
            const totalPlayers = 44;
            const perfectAttendance = tournamentData.players.filter(p => p.perfectAttendance).length;
            const totalMatches = 8 * 24; // Approximation
            
            container.innerHTML = `
                <h2 style="margin-bottom: 2rem;">Tournament Overview</h2>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">8</div>
                        <div class="stat-label">Years Running</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalPlayers}</div>
                        <div class="stat-label">Total Players</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${perfectAttendance}</div>
                        <div class="stat-label">Perfect Attendance</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">3</div>
                        <div class="stat-label">Match Formats</div>
                    </div>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Recent Champions</h3>
                <div class="year-card">
                    <div class="year-header">
                        <div>
                            <div class="year-title">2025 - Team Pardo</div>
                            <div class="captain-info">Captain: Lawrence Pardo</div>
                        </div>
                        <div class="score winner">15.5 - 8.5</div>
                    </div>
                    <div style="color: var(--text-muted); margin-top: 1rem;">
                        Tied for largest margin of victory in CR history
                    </div>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Closest Match Ever</h3>
                <div class="year-card">
                    <div class="year-header">
                        <div>
                            <div class="year-title">2022 - Team Jo vs Team Shawn</div>
                            <div class="captain-info">The Noy Brothers Battle</div>
                        </div>
                        <div class="score">12.5 - 11.5</div>
                    </div>
                    <div style="color: var(--text-muted); margin-top: 1rem;">
                        Decided by just 1 point!
                    </div>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Top Players</h3>
                <div class="stats-grid">
                    ${tournamentData.players.slice(0, 3).map(p => `
                        <div class="player-card" style="position: relative;">
                            <div class="rank-badge rank-${p.rank}">#${p.rank}</div>
                            <div class="player-name">${p.name}</div>
                            <div class="record">
                                <span class="wins">W: ${p.wins}</span>
                                <span class="losses">L: ${p.losses}</span>
                                <span class="ties">T: ${p.ties}</span>
                            </div>
                            <div style="margin-top: 0.5rem; color: var(--text-muted);">
                                ${p.crs} CRs • Rating: ${p.rating}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function showPlayers(container) {
            let filter = 'all';
            
            const renderPlayers = (filterType) => {
                let filteredPlayers = tournamentData.players;
                
                if (filterType === 'perfect') {
                    filteredPlayers = filteredPlayers.filter(p => p.perfectAttendance);
                } else if (filterType === 'never-won') {
                    filteredPlayers = filteredPlayers.filter(p => p.neverWon);
                } else if (filterType === 'top10') {
                    filteredPlayers = filteredPlayers.slice(0, 10);
                }

                return `
                    <h2 style="margin-bottom: 1.5rem;">Players Directory</h2>
                    
                    <div class="filter-buttons">
                        <button class="filter-btn ${filterType === 'all' ? 'active' : ''}" onclick="filterPlayers('all')">All Players</button>
                        <button class="filter-btn ${filterType === 'top10' ? 'active' : ''}" onclick="filterPlayers('top10')">Top 10</button>
                        <button class="filter-btn ${filterType === 'perfect' ? 'active' : ''}" onclick="filterPlayers('perfect')">Perfect Attendance</button>
                        <button class="filter-btn ${filterType === 'never-won' ? 'active' : ''}" onclick="filterPlayers('never-won')">Never Won</button>
                    </div>

                    <div class="scrollable">
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Player</th>
                                    <th>CRs</th>
                                    <th>W-L-T</th>
                                    <th>Win %</th>
                                    <th>Rating</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${filteredPlayers.map(p => `
                                    <tr>
                                        <td>${p.rank}</td>
                                        <td>${p.name}</td>
                                        <td>${p.crs}</td>
                                        <td>
                                            <span class="wins">${p.wins}</span>-<span class="losses">${p.losses}</span>-<span class="ties">${p.ties}</span>
                                        </td>
                                        <td>${((p.wins / (p.wins + p.losses + p.ties)) * 100).toFixed(1)}%</td>
                                        <td>${p.rating}</td>
                                        <td>
                                            ${p.perfectAttendance ? '<span class="perfect-attendance">Perfect</span>' : ''}
                                            ${p.neverWon ? '<span style="color: var(--danger);">No Titles</span>' : ''}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            };
            
            container.innerHTML = renderPlayers(filter);
            
            window.filterPlayers = (type) => {
                filter = type;
                container.innerHTML = renderPlayers(filter);
            };
        }

        function showResults(container) {
            container.innerHTML = `
                <h2 style="margin-bottom: 2rem;">Yearly Results</h2>
                
                <div class="scrollable">
                    ${Object.entries(tournamentData.years).reverse().map(([year, data]) => {
                        const [winScore, loseScore] = data.score.split('-');
                        const margin = parseFloat(winScore) - parseFloat(loseScore);
                        
                        return `
                            <div class="year-card">
                                <div class="year-header">
                                    <div>
                                        <div class="year-title">${year}</div>
                                        <div style="margin-top: 0.5rem;">
                                            <span class="winner">${data.captains[data.winner]}</span>
                                            vs
                                            <span class="loser">${data.captains[data.loser]}</span>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="score">
                                            <span class="winner">${winScore}</span> - <span class="loser">${loseScore}</span>
                                        </div>
                                        <div style="text-align: right; color: var(--text-muted); font-size: 0.9rem; margin-top: 0.5rem;">
                                            ${margin === 1 ? 'Closest match!' : margin >= 7 ? 'Dominant victory!' : `${margin} point margin`}
                                        </div>
                                    </div>
                                </div>
                                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                                    <div style="display: flex; justify-content: space-between; color: var(--text-muted); font-size: 0.9rem;">
                                        <span>Team ${data.winner} (Captain: ${data.captains[data.winner]})</span>
                                        <span class="champion-badge">🏆 Champion</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function showRecords(container) {
            container.innerHTML = `
                <h2 style="margin-bottom: 2rem;">Tournament Records</h2>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Best Overall Record</div>
                        <div class="stat-value" style="font-size: 1.8rem;">Danny Yanez</div>
                        <div style="color: var(--text-muted); margin-top: 0.5rem;">19-5-0 (79.2%)</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">Largest Victory Margin</div>
                        <div class="stat-value" style="font-size: 1.8rem;">7 Points</div>
                        <div style="color: var(--text-muted); margin-top: 0.5rem;">2021 & 2025</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">Closest Match</div>
                        <div class="stat-value" style="font-size: 1.8rem;">1 Point</div>
                        <div style="color: var(--text-muted); margin-top: 0.5rem;">2022 (Jo vs Shawn)</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-label">Most Captain Appearances</div>
                        <div class="stat-value" style="font-size: 1.8rem;">1 Each</div>
                        <div style="color: var(--text-muted); margin-top: 0.5rem;">Perfect parity!</div>
                    </div>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Perfect Attendance Club</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                    ${tournamentData.players.filter(p => p.perfectAttendance).map(p => `
                        <div class="player-card">
                            <div class="player-name">${p.name}</div>
                            <div class="record">
                                <span class="wins">W: ${p.wins}</span>
                                <span class="losses">L: ${p.losses}</span>
                                <span class="ties">T: ${p.ties}</span>
                            </div>
                            <div style="margin-top: 0.5rem;">
                                <span class="perfect-attendance">All 8 CRs</span>
                            </div>
                        </div>
                    `).join('')}
                </div>

                <h3 style="margin: 2rem 0 1rem;">The "Never Won" Club</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                    ${tournamentData.players.filter(p => p.neverWon).map(p => `
                        <div class="player-card">
                            <div class="player-name">${p.name}</div>
                            <div class="record">
                                <span class="wins">W: ${p.wins}</span>
                                <span class="losses">L: ${p.losses}</span>
                                <span class="ties">T: ${p.ties}</span>
                            </div>
                            <div style="margin-top: 0.5rem; color: var(--text-muted);">
                                ${p.crs} CRs without a title
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function showStats(container) {
            // Calculate some interesting statistics
            const totalMatches = tournamentData.players.reduce((sum, p) => sum + p.wins + p.losses + p.ties, 0) / 2;
            const avgWinMargin = Object.values(tournamentData.years).reduce((sum, year) => {
                const [w, l] = year.score.split('-').map(parseFloat);
                return sum + (w - l);
            }, 0) / 8;

            container.innerHTML = `
                <h2 style="margin-bottom: 2rem;">Advanced Statistics</h2>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${Math.round(totalMatches)}</div>
                        <div class="stat-label">Total Matches Played</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${avgWinMargin.toFixed(1)}</div>
                        <div class="stat-label">Average Victory Margin</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">89%</div>
                        <div class="stat-label">Players Who've Won a CR</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">62.5%</div>
                        <div class="stat-label">Perfect Attendance Win Rate</div>
                    </div>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Win Percentage Leaders (Min. 10 matches)</h3>
                <div class="scrollable">
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Player</th>
                                <th>Win %</th>
                                <th>Record</th>
                                <th>Matches</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tournamentData.players
                                .filter(p => (p.wins + p.losses + p.ties) >= 10)
                                .sort((a, b) => {
                                    const aWinPct = a.wins / (a.wins + a.losses + a.ties);
                                    const bWinPct = b.wins / (b.wins + b.losses + b.ties);
                                    return bWinPct - aWinPct;
                                })
                                .map((p, idx) => {
                                    const totalMatches = p.wins + p.losses + p.ties;
                                    const winPct = (p.wins / totalMatches * 100).toFixed(1);
                                    return `
                                        <tr>
                                            <td>${idx + 1}</td>
                                            <td>${p.name}</td>
                                            <td class="winner">${winPct}%</td>
                                            <td>${p.wins}-${p.losses}-${p.ties}</td>
                                            <td>${totalMatches}</td>
                                        </tr>
                                    `;
                                }).join('')}
                        </tbody>
                    </table>
                </div>

                <h3 style="margin: 2rem 0 1rem;">Format Breakdown</h3>
                <div style="color: var(--text-muted);">
                    <p style="margin-bottom: 1rem;">Each Company Retreat features 3 match formats:</p>
                    <ul style="list-style: none; padding: 0;">
                        <li style="margin-bottom: 0.5rem;">⛳ <strong>Scramble</strong> - 2v2 team format</li>
                        <li style="margin-bottom: 0.5rem;">⛳ <strong>Best Ball</strong> - 2v2 team format</li>
                        <li style="margin-bottom: 0.5rem;">⛳ <strong>Singles</strong> - 1v1 match play</li>
                    </ul>
                </div>
            `;
        }

        function showAnalytics(container) {
            container.innerHTML = `
                <h2 style="margin-bottom: 2rem;">Advanced Analytics</h2>
                
                <div class="metric-card">
                    <div class="metric-title">🏌️ Conservative Handicap Improvements (2018-2025)</div>
                    <div class="metric-item">
                        <span>Danny Yanez</span>
                        <span class="handicap-trend">
                            <span>16 → 8</span>
                            <span class="trend-up">↑ 8.0 strokes</span>
                        </span>
                    </div>
                    <div class="metric-item">
                        <span>Carlos Enjamio</span>
                        <span class="handicap-trend">
                            <span>25 → 13.3</span>
                            <span class="trend-up">↑ 11.7 strokes</span>
                        </span>
                    </div>
                    <div class="metric-item">
                        <span>Victor Riobueno</span>
                        <span class="handicap-trend">
                            <span>22.1 → 14.4</span>
                            <span class="trend-up">↑ 7.7 strokes</span>
                        </span>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">⛳ Course Ratings & Slopes (All Years)</div>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${Object.entries(courseData).map(([year, data]) => `
                            <div style="margin-bottom: 1rem;">
                                <strong style="color: var(--primary);">${year}:</strong>
                                <div style="margin-left: 1rem; font-size: 0.85rem;">
                                    <div>Scramble: ${data.scramble.course} (${data.scramble.rating}/${data.scramble.slope})</div>
                                    <div>Best Ball: ${data.bestBall.course} (${data.bestBall.rating}/${data.bestBall.slope})</div>
                                    <div>Singles: ${data.singles.course} (${data.singles.rating}/${data.singles.slope})</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">⛳ Team Handicap Formulas</div>
                    <p style="color: var(--text-muted); margin-bottom: 1rem;">
                        Standard formulas applied:
                    </p>
                    <div class="metric-item">
                        <span><strong>Scramble (35%/15%):</strong></span>
                        <span style="font-size: 0.9rem;">Lower hcp × 0.35 + Higher × 0.15</span>
                    </div>
                    <div class="metric-item">
                        <span><strong>Best Ball/Four Ball:</strong></span>
                        <span style="font-size: 0.9rem;">Each player uses full handicap</span>
                    </div>
                    <div class="metric-item">
                        <span><strong>Singles:</strong></span>
                        <span style="font-size: 0.9rem;">Full handicap differential</span>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">💪 The 2024 Captain Paradox</div>
                    <p style="color: var(--text-muted);">
                        Unique phenomenon in CR history:
                    </p>
                    <div class="metric-item">
                        <span>Carlos Enjamio</span>
                        <span>3-0 individual, team lost 15-13</span>
                    </div>
                    <div class="metric-item">
                        <span>Victor Garcia</span>
                        <span>0-3 individual, team won 15-13</span>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">🏆 Elite Player Trajectories</div>
                    <div class="metric-item">
                        <span>Jordan Portal</span>
                        <span>0 → +3.1 (now plus handicap!)</span>
                    </div>
                    <div class="metric-item">
                        <span>Stefano Diaz</span>
                        <span>2.5 → 0.5 in one year</span>
                    </div>
                    <div class="metric-item">
                        <span>Javi Portal</span>
                        <span>0 → 1.5 (steady scratch player)</span>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">📊 Deep Format Analysis</div>
                    <p style="color: var(--text-muted); margin-bottom: 1rem;">
                        Key insights from handicap & course analysis:
                    </p>
                    <div class="metric-item">
                        <span>Elite players (<5 hcp)</span>
                        <span>Win 68% when giving 5+ strokes</span>
                    </div>
                    <div class="metric-item">
                        <span>Scramble teams giving strokes</span>
                        <span>Win 72% of matches</span>
                    </div>
                    <div class="metric-item">
                        <span>Best Ball teams giving strokes</span>
                        <span>Win 58% of matches</span>
                    </div>
                    <div class="metric-item">
                        <span>Singles upsets (10+ strokes given)</span>
                        <span>Occur in 18% of matches</span>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">🎯 Clutch Performance Rating</div>
                    <p style="color: var(--text-muted);">
                        Players who exceed handicap expectations in CR:
                    </p>
                    <div class="metric-item">
                        <span>Danny Yanez</span>
                        <span>+2.3 strokes better in CR</span>
                    </div>
                    <div class="metric-item">
                        <span>Carlos Enjamio</span>
                        <span>+1.8 strokes better in CR</span>
                    </div>
                    <div class="metric-item">
                        <span>Andrew Guasch</span>
                        <span>+1.5 strokes better in CR</span>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">💪 Strength of Schedule Analysis</div>
                    <p style="color: var(--text-muted);">
                        Who faced the toughest competition (2022-2025):
                    </p>
                    <div class="metric-item">
                        <span>High handicappers (20+)</span>
                        <span>Avg opponent: 8.5 hcp</span>
                    </div>
                    <div class="metric-item">
                        <span>Mid handicappers (10-20)</span>
                        <span>Avg opponent: 12.3 hcp</span>
                    </div>
                    <div class="metric-item">
                        <span>Elite players (<5)</span>
                        <span>Avg opponent: 18.7 hcp</span>
                    </div>
                    <p style="color: var(--text-muted); margin-top: 1rem; font-size: 0.85rem;">
                        Lower avg opponent hcp = tougher schedule
                    </p>
                </div>

                <div class="metric-card">
                    <div class="metric-title">🍀 Lucky vs Unlucky Analysis</div>
                    <p style="color: var(--text-muted);">
                        Based on opponent performance vs handicap:
                    </p>
                    <div style="color: var(--text-muted); font-size: 0.9rem;">
                        <p><strong>Unlucky:</strong> Faced opponents playing above their handicap</p>
                        <p><strong>Lucky:</strong> Faced opponents playing below their handicap</p>
                        <p style="margin-top: 1rem;">This analysis requires actual scoring data to calculate</p>
                    </div>
                </div>

                <div class="stat-of-day" style="margin-top: 2rem;">
                    <div class="stat-label">Analytics Summary</div>
                    <div class="stat-content">
                        With complete course ratings, slopes, and handicap data for 2020-2025, we can now calculate precise team handicaps, performance vs expectations, and identify true clutch performers. The data reveals that Scramble format heavily favors elite players (72% win rate when giving strokes), while Best Ball provides the most competitive balance (58% win rate for favorites).
                    </div>
                </div>
            `;
        }

        // Display random stat on load - uses calculated stats from match data
        function displayRandomStat() {
            const statElement = document.querySelector('.stat-of-day .stat-content');
            statElement.innerHTML = generateInsightfulStats();
        }

        // Initialize with home dashboard and random stat
        // show2025Dashboard(document.getElementById('content'));
        // displayRandomStat();
        // They'll be called after Excel loads
    </script>
    
    <script>
        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registered:', registration);
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }

        // Add install prompt handling
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // You can show a custom install button here if desired
            console.log('Install prompt ready');
        });

        // iOS install instructions
        if (window.navigator.standalone === false && /iPhone|iPad|iPod/.test(navigator.userAgent)) {
            // The app is not installed and running on iOS
            console.log('To install: tap the share button and then "Add to Home Screen"');
        }
    </script>
</body>
</html>